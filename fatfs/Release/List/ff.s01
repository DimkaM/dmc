	NAME	ff(16)
	RSEG	CODE(0)
	RSEG	CSTR(0)
	EXTERN	CurrVol
	EXTERN	FatFs
	EXTERN	Fsid
	EXTERN	LD_CLUST
	PUBLIC	clust2sect
	EXTERN	dio_par
	EXTERN	disk_initialize
	EXTERN	disk_ioctl
	EXTERN	disk_read
	EXTERN	disk_write
	EXTERN	ds_m
	PUBLIC	f_chdir
	PUBLIC	f_chdrive
	PUBLIC	f_chmod
	PUBLIC	f_close
	PUBLIC	f_getfree
	PUBLIC	f_lseek
	PUBLIC	f_mkdir
	PUBLIC	f_mount
	PUBLIC	f_open
	PUBLIC	f_opendir
	PUBLIC	f_read
	PUBLIC	f_readdir
	PUBLIC	f_rename
	PUBLIC	f_stat
	PUBLIC	f_sync
	PUBLIC	f_truncate
	PUBLIC	f_unlink
	PUBLIC	f_utime
	PUBLIC	f_write
	PUBLIC	get_fat
	EXTERN	get_fattime
	PUBLIC	put_fat
	EXTERN	?CLZ80L_4_06_L00
	EXTERN	?US_RSH_L02
	EXTERN	?L_LSH_L03
	EXTERN	?UL_RSH_L03
	EXTERN	?L_MUL_L03
	EXTERN	?UL_DIV_L03
	EXTERN	?L_AND_L03
	EXTERN	?L_INC_L03
	EXTERN	?L_DEC_L03
	EXTERN	?L_NOT_L03
	EXTERN	?L_MULASG_L03
	EXTERN	?L_ADDASG_L03
	EXTERN	?L_SUBASG_L03
	EXTERN	?L_ORASG_L03
	EXTERN	?L_INCASG_L03
	EXTERN	?ENT_PARM_DIRECT_L09
	EXTERN	?ENT_AUTO_DIRECT_L09
	EXTERN	?LEAVE_DIRECT_L09
	EXTERN	?LEAVE_32_L09
	EXTERN	?MEMSET_L11
	EXTERN	?MEMCMP_L11
	EXTERN	?STRCHR_L11
	RSEG	CODE
; 1.	/*----------------------------------------------------------------------------/
; 2.	/  FatFs - FAT file system module  R0.08b                 (C)ChaN, 2011
; 3.	/-----------------------------------------------------------------------------/
; 4.	/ FatFs module is a generic FAT file system module for small embedded systems.
; 5.	/ This is a free software that opened for education, research and commercial
; 6.	/ developments under license policy of following terms.
; 7.	/
; 8.	/  Copyright (C) 2011, ChaN, all right reserved.
; 9.	/
; 10.	/ * The FatFs module is a free software and there is NO WARRANTY.
; 11.	/ * No restriction on use. You can use, modify and redistribute it for
; 12.	/   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
; 13.	/ * Redistributions of source code must retain the above copyright notice.
; 14.	/
; 15.	/-----------------------------------------------------------------------------/
; 16.	/ Feb 26,'06 R0.00  Prototype.
; 17.	/
; 18.	/ Apr 29,'06 R0.01  First stable version.
; 19.	/
; 20.	/ Jun 01,'06 R0.02  Added FAT12 support.
; 21.	/                   Removed unbuffered mode.
; 22.	/                   Fixed a problem on small (<32M) partition.
; 23.	/ Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
; 24.	/
; 25.	/ Sep 22,'06 R0.03  Added f_rename().
; 26.	/                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
; 27.	/ Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
; 28.	/                   Fixed f_mkdir() creates incorrect directory on FAT32.
; 29.	/
; 30.	/ Feb 04,'07 R0.04  Supported multiple drive system.
; 31.	/                   Changed some interfaces for multiple drive system.
; 32.	/                   Changed f_mountdrv() to f_mount().
; 33.	/                   Added f_mkfs().
; 34.	/ Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
; 35.	/                   Added a capability of extending file size to f_lseek().
; 36.	/                   Added minimization level 3.
; 37.	/                   Fixed an endian sensitive code in f_mkfs().
; 38.	/ May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
; 39.	/                   Added FSInfo support.
; 40.	/                   Fixed DBCS name can result FR_INVALID_NAME.
; 41.	/                   Fixed short seek (<= csize) collapses the file object.
; 42.	/
; 43.	/ Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
; 44.	/                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
; 45.	/                   Fixed f_mkdir() on FAT32 creates incorrect directory.
; 46.	/ Feb 03,'08 R0.05a Added f_truncate() and f_utime().
; 47.	/                   Fixed off by one error at FAT sub-type determination.
; 48.	/                   Fixed btr in f_read() can be mistruncated.
; 49.	/                   Fixed cached sector is not flushed when create and close without write.
; 50.	/
; 51.	/ Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
; 52.	/                   Improved performance of f_lseek() on moving to the same or following cluster.
; 53.	/
; 54.	/ Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
; 55.	/                   Added long file name feature.
; 56.	/                   Added multiple code page feature.
; 57.	/                   Added re-entrancy for multitask operation.
; 58.	/                   Added auto cluster size selection to f_mkfs().
; 59.	/                   Added rewind option to f_readdir().
; 60.	/                   Changed result code of critical errors.
; 61.	/                   Renamed string functions to avoid name collision.
; 62.	/ Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
; 63.	/                   Added multiple sector size feature.
; 64.	/ Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
; 65.	/                   Fixed wrong cache control in f_lseek().
; 66.	/                   Added relative path feature.
; 67.	/                   Added f_chdir() and f_chdrive().
; 68.	/                   Added proper case conversion to extended char.
; 69.	/ Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
; 70.	/                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
; 71.	/                   Fixed name matching error on the 13 char boundary.
; 72.	/                   Added a configuration option, _LFN_UNICODE.
; 73.	/                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
; 74.	/
; 75.	/ May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
; 76.	/                   Added file lock feature. (_FS_SHARE)
; 77.	/                   Added fast seek feature. (_USE_FASTSEEK)
; 78.	/                   Changed some types on the API, XCHAR->TCHAR.
; 79.	/                   Changed fname member in the FILINFO structure on Unicode cfg.
; 80.	/                   String functions support UTF-8 encoding files on Unicode cfg.
; 81.	/ Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
; 82.	/                   Added sector erase feature. (_USE_ERASE)
; 83.	/                   Moved file lock semaphore table from fs object to the bss.
; 84.	/                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
; 85.	/                   Fixed f_mkfs() creates wrong FAT32 volume.
; 86.	/ Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
; 87.	/                   f_lseek() reports required table size on creating CLMP.
; 88.	/                   Extended format syntax of f_printf function.
; 89.	/                   Ignores duplicated directory separators in given path names.
; 90.	/---------------------------------------------------------------------------*/
; 91.	
; 92.	#include "ff.h"                 /* FatFs configurations and declarations */
; 93.	#include "diskio.h"             /* Declarations of low level disk I/O functions */
; 94.	#include <string.h>
; 95.	
; 96.	/*--------------------------------------------------------------------------
; 97.	
; 98.	   Module Private Definitions
; 99.	
; 100.	---------------------------------------------------------------------------*/
; 101.	
; 102.	#if _FATFS != 8237
; 104.	#endif
; 105.	
; 106.	
; 107.	/* Definitions on sector size */
; 108.	#if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
; 110.	#endif
; 111.	#if _MAX_SS != 512
; 113.	#else
; 114.	#define SS(fs)  512U                    /* Fixed sector size */
; 115.	#endif
; 116.	
; 117.	
; 118.	/* Reentrancy related */
; 119.	#if _FS_REENTRANT
; 120.	#if _USE_LFN == 1
; 122.	#endif
; 125.	#else
; 126.	#define ENTER_FF(fs)
; 127.	#define LEAVE_FF(fs, res)       return res
; 128.	#endif
; 129.	
; 130.	#define ABORT(fs, res)          { fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
; 131.	
; 132.	
; 133.	/* File shareing feature */
; 134.	#if _FS_SHARE
; 135.	#if _FS_READONLY
; 137.	#endif
; 144.	#endif
; 145.	
; 146.	
; 147.	/* Misc definitions */
; 148.	//#define LD_CLUST(dir) (((DWORD)LD_WORD(dir+DIR_FstClusHI)<<16) | LD_WORD(dir+DIR_FstClusLO))
; 149.	#define ST_CLUST(dir,cl) {ST_WORD(dir+DIR_FstClusLO, cl); ST_WORD(dir+DIR_FstClusHI, (DWORD)cl>>16);}
; 150.	
; 151.	
; 152.	/* DBCS code ranges and SBCS extend char conversion table */
; 153.	
; 154.	#if _CODE_PAGE == 932   /* Japanese Shift-JIS */
; 164.	#elif _CODE_PAGE == 936 /* Simplified Chinese GBK */
; 172.	#elif _CODE_PAGE == 949 /* Korean */
; 182.	#elif _CODE_PAGE == 950 /* Traditional Chinese Big5 */
; 190.	#elif _CODE_PAGE == 437 /* U.S. (OEM) */
; 197.	#elif _CODE_PAGE == 720 /* Arabic (OEM) */
; 204.	#elif _CODE_PAGE == 737 /* Greek (OEM) */
; 211.	#elif _CODE_PAGE == 775 /* Baltic (OEM) */
; 218.	#elif _CODE_PAGE == 850 /* Multilingual Latin 1 (OEM) */
; 225.	#elif _CODE_PAGE == 852 /* Latin 2 (OEM) */
; 232.	#elif _CODE_PAGE == 855 /* Cyrillic (OEM) */
; 239.	#elif _CODE_PAGE == 857 /* Turkish (OEM) */
; 246.	#elif _CODE_PAGE == 858 /* Multilingual Latin 1 + Euro (OEM) */
; 253.	#elif _CODE_PAGE == 862 /* Hebrew (OEM) */
; 260.	#elif _CODE_PAGE == 866 /* Russian (OEM) */
; 267.	#elif _CODE_PAGE == 874 /* Thai (OEM, Windows) */
; 274.	#elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
; 281.	#elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
; 288.	#elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
; 295.	#elif _CODE_PAGE == 1253 /* Greek (Windows) */
; 302.	#elif _CODE_PAGE == 1254 /* Turkish (Windows) */
; 309.	#elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
; 316.	#elif _CODE_PAGE == 1256 /* Arabic (Windows) */
; 323.	#elif _CODE_PAGE == 1257 /* Baltic (Windows) */
; 330.	#elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
; 337.	#elif _CODE_PAGE == 1   /* ASCII (for only non-LFN cfg) */
; 338.	#if _USE_LFN
; 340.	#endif
; 341.	#define _DF1S   0
; 342.	
; 343.	#else
; 346.	#endif
; 347.	
; 348.	
; 349.	/* Character code support macros */
; 350.	#define IsUpper(c)      (((c)>='A')&&((c)<='Z'))
; 351.	#define IsLower(c)      (((c)>='a')&&((c)<='z'))
; 352.	#define IsDigit(c)      (((c)>='0')&&((c)<='9'))
; 353.	
; 354.	#if _DF1S               /* Code page is DBCS */
; 356.	#ifdef _DF2S    /* Two 1st byte areas */
; 358.	#else                   /* One 1st byte area */
; 360.	#endif
; 362.	#ifdef _DS3S    /* Three 2nd byte areas */
; 364.	#else                   /* Two 2nd byte areas */
; 366.	#endif
; 368.	#else                   /* Code page is SBCS */
; 369.	
; 370.	#define IsDBCS1(c)      0
; 371.	#define IsDBCS2(c)      0
; 372.	
; 373.	#endif /* _DF1S */
; 374.	
; 375.	
; 376.	/* Name status flags */
; 377.	#define NS                      11              /* Index of name status byte in fn[] */
; 378.	#define NS_LOSS         0x01    /* Out of 8.3 format */
; 379.	#define NS_LFN          0x02    /* Force to create LFN entry */
; 380.	#define NS_LAST         0x04    /* Last segment */
; 381.	#define NS_BODY         0x08    /* Lower case flag (body) */
; 382.	#define NS_EXT          0x10    /* Lower case flag (ext) */
; 383.	#define NS_DOT          0x20    /* Dot entry */
; 384.	
; 385.	
; 386.	/* FAT sub-type boundaries */
; 387.	/* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
; 388.	#define MIN_FAT16       4086    /* Minimum number of clusters for FAT16 */
; 389.	#define MIN_FAT32       65526   /* Minimum number of clusters for FAT32 */
; 390.	
; 391.	
; 392.	/* FatFs refers the members in the FAT structures as byte array instead of
; 393.	/ structure member because the structure is not binary compatible between
; 394.	/ different platforms */
; 395.	
; 396.	#define BS_jmpBoot                      0       /* Jump instruction (3) */
; 397.	#define BS_OEMName                      3       /* OEM name (8) */
; 398.	#define BPB_BytsPerSec          11      /* Sector size [byte] (2) */
; 399.	#define BPB_SecPerClus          13      /* Cluster size [sector] (1) */
; 400.	#define BPB_RsvdSecCnt          14      /* Size of reserved area [sector] (2) */
; 401.	#define BPB_NumFATs                     16      /* Number of FAT copies (1) */
; 402.	#define BPB_RootEntCnt          17      /* Number of root dir entries for FAT12/16 (2) */
; 403.	#define BPB_TotSec16            19      /* Volume size [sector] (2) */
; 404.	#define BPB_Media                       21      /* Media descriptor (1) */
; 405.	#define BPB_FATSz16                     22      /* FAT size [sector] (2) */
; 406.	#define BPB_SecPerTrk           24      /* Track size [sector] (2) */
; 407.	#define BPB_NumHeads            26      /* Number of heads (2) */
; 408.	#define BPB_HiddSec                     28      /* Number of special hidden sectors (4) */
; 409.	#define BPB_TotSec32            32      /* Volume size [sector] (4) */
; 410.	#define BS_DrvNum                       36      /* Physical drive number (2) */
; 411.	#define BS_BootSig                      38      /* Extended boot signature (1) */
; 412.	#define BS_VolID                        39      /* Volume serial number (4) */
; 413.	#define BS_VolLab                       43      /* Volume label (8) */
; 414.	#define BS_FilSysType           54      /* File system type (1) */
; 415.	#define BPB_FATSz32                     36      /* FAT size [sector] (4) */
; 416.	#define BPB_ExtFlags            40      /* Extended flags (2) */
; 417.	#define BPB_FSVer                       42      /* File system version (2) */
; 418.	#define BPB_RootClus            44      /* Root dir first cluster (4) */
; 419.	#define BPB_FSInfo                      48      /* Offset of FSInfo sector (2) */
; 420.	#define BPB_BkBootSec           50      /* Offset of backup boot sectot (2) */
; 421.	#define BS_DrvNum32                     64      /* Physical drive number (2) */
; 422.	#define BS_BootSig32            66      /* Extended boot signature (1) */
; 423.	#define BS_VolID32                      67      /* Volume serial number (4) */
; 424.	#define BS_VolLab32                     71      /* Volume label (8) */
; 425.	#define BS_FilSysType32         82      /* File system type (1) */
; 426.	#define FSI_LeadSig                     0       /* FSI: Leading signature (4) */
; 427.	#define FSI_StrucSig            484     /* FSI: Structure signature (4) */
; 428.	#define FSI_Free_Count          488     /* FSI: Number of free clusters (4) */
; 429.	#define FSI_Nxt_Free            492     /* FSI: Last allocated cluster (4) */
; 430.	#define MBR_Table                       446     /* MBR: Partition table offset (2) */
; 431.	#define SZ_PTE                          16      /* MBR: Size of a partition table entry */
; 432.	#define BS_55AA                         510     /* Boot sector signature (2) */
; 433.	
; 434.	#define DIR_Name                        0       /* Short file name (11) */
; 435.	#define DIR_Attr                        11      /* Attribute (1) */
; 436.	#define DIR_NTres                       12      /* NT flag (1) */
; 437.	#define DIR_CrtTime                     14      /* Created time (2) */
; 438.	#define DIR_CrtDate                     16      /* Created date (2) */
; 439.	#define DIR_FstClusHI           20      /* Higher 16-bit of first cluster (2) */
; 440.	#define DIR_WrtTime                     22      /* Modified time (2) */
; 441.	#define DIR_WrtDate                     24      /* Modified date (2) */
; 442.	#define DIR_FstClusLO           26      /* Lower 16-bit of first cluster (2) */
; 443.	#define DIR_FileSize            28      /* File size (4) */
; 444.	#define LDIR_Ord                        0       /* LFN entry order and LLE flag (1) */
; 445.	#define LDIR_Attr                       11      /* LFN attribute (1) */
; 446.	#define LDIR_Type                       12      /* LFN type (1) */
; 447.	#define LDIR_Chksum                     13      /* Sum of corresponding SFN entry */
; 448.	#define LDIR_FstClusLO          26      /* Filled by zero (0) */
; 449.	#define SZ_DIR                          32              /* Size of a directory entry */
; 450.	#define LLE                                     0x40    /* Last long entry flag in LDIR_Ord */
; 451.	#define DDE                                     0xE5    /* Deleted directory enrty mark in DIR_Name[0] */
; 452.	#define NDDE                            0x05    /* Replacement of a character collides with DDE */
; 453.	
; 454.	
; 455.	/*------------------------------------------------------------*/
; 456.	/* Work area                                                  */
; 457.	
; 458.	#if _VOLUMES
; 459.	extern
; 460.	FATFS *FatFs[_VOLUMES]; /* Pointer to the file system objects (logical drives) */
; 461.	#else
; 463.	#endif
; 464.	
; 465.	extern WORD Fsid;                               /* File system mount ID */
; 466.	
; 467.	#if _FS_RPATH
; 468.	extern
; 469.	BYTE CurrVol;                   /* Current drive */
; 470.	#endif
; 471.	
; 472.	#if _FS_SHARE
; 475.	#endif
; 476.	
; 477.	#if _USE_LFN == 0                       /* No LFN */
; 478.	#define DEF_NAMEBUF                     BYTE sfn[12]
; 479.	#define INIT_BUF(dobj)          (dobj).fn = sfn
; 480.	#define FREE_BUF()
; 481.	
; 482.	#elif _USE_LFN == 1                     /* LFN with static LFN working buffer */
; 488.	#elif _USE_LFN == 2             /* LFN with dynamic LFN working buffer on the stack */
; 493.	#elif _USE_LFN == 3             /* LFN with dynamic LFN working buffer on the heap */
; 500.	#else
; 502.	#endif
; 503.	
; 504.	
; 505.	
; 506.	
; 507.	/*--------------------------------------------------------------------------
; 508.	
; 509.	   Module Private Functions
; 510.	
; 511.	---------------------------------------------------------------------------*/
; 512.	
; 513.	extern DWORD LD_CLUST(BYTE *);
; 514.	
; 515.	
; 516.	/*-----------------------------------------------------------------------*/
; 517.	/* String functions                                                      */
; 518.	/*-----------------------------------------------------------------------*/
; 519.	
; 520.	
; 521.	/*-----------------------------------------------------------------------*/
; 522.	/* Request/Release grant to access the volume                            */
; 523.	/*-----------------------------------------------------------------------*/
; 524.	#if _FS_REENTRANT
; 548.	#endif
; 549.	
; 550.	
; 551.	
; 552.	/*-----------------------------------------------------------------------*/
; 553.	/* File shareing control functions                                       */
; 554.	/*-----------------------------------------------------------------------*/
; 555.	#if _FS_SHARE
; 661.	#endif
; 662.	
; 663.	
; 664.	
; 665.	/*-----------------------------------------------------------------------*/
; 666.	/* Change window offset                                                  */
; 667.	/*-----------------------------------------------------------------------*/
; 668.	
; 669.	static
; 670.	FRESULT move_window (
; 671.	        FATFS *fs,              /* File system object */
; 672.	        DWORD sector    /* Sector number to make appearance in the fs->win[] */
; 673.	)                                       /* Move to zero only writes back dirty window */
move_window:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	65530
	PUSH	IY
	LD	L,(IX+2)
	LD	H,(IX+3)
	PUSH	HL
	POP	IY
; 674.	{
; 675.	        DWORD wsect;
; 676.	
; 677.	
	LD	C,(IY+49)
	LD	B,(IY+50)
	LD	L,(IY+47)
	LD	H,(IY+48)
	LD	(IX-6),L
	LD	(IX-5),H
	LD	(IX-4),C
	LD	(IX-3),B
; 678.	        wsect = fs->winsect;
	LD	E,C
	LD	D,B
	LD	C,(IX+8)
	LD	B,(IX+9)
	AND	A
	SBC	HL,BC
	JR	NZ,?0921
	EX	DE,HL
	LD	C,(IX+10)
	LD	B,(IX+11)
	SBC	HL,BC
	JP	Z,?0017
?0921:
?0004:
; 679.	        if (wsect != sector) {  /* Changed current window */
; 680.	#if !_FS_READONLY
	LD	A,(IY+5)
	OR	A
	JP	Z,?0012
?0006:
; 681.	                if (fs->wflag) {        /* Write back dirty window if needed */
	LD	A,(IY+1)
	LD	(dio_par),A
	LD	HL,51
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	(dio_par+1),HL
	LD	HL,2
	ADD	HL,SP
; 682.	                        SET_DIO_PAR(fs->drv, fs->win, wsect,1);
	CALL	?1036
	OR	A
	JP	NZ,?0922
?0008:
; 683.	                        if (disk_write() != RES_OK)
; 684.	                                return FR_DISK_ERR;
?0009:
	LD	(IY+5),A
; 685.	                        fs->wflag = 0;
	LD	L,(IY+33)
	LD	H,(IY+34)
	PUSH	HL
	LD	L,(IY+31)
	LD	H,(IY+32)
	PUSH	HL
	LD	L,(IY+35)
	LD	H,(IY+36)
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	LD	L,(IY+37)
	LD	H,(IY+38)
	POP	BC
	ADC	HL,BC
	PUSH	HL
	PUSH	DE
	AND	A
	LD	L,(IX-6)
	LD	H,(IX-5)
	POP	BC
	SBC	HL,BC
	LD	L,(IX-4)
	LD	H,(IX-3)
	POP	BC
	SBC	HL,BC
	JR	NC,?0012
?0010:
; 686.	                        if (wsect < (fs->fatbase + fs->fsize)) {        /* In FAT area */
; 687.	                                BYTE nf;
	LD	B,(IY+4)
	LD	(IX-2),B
?0013:
	LD	A,1
	CP	(IX-2)
	JR	NC,?0012
?0014:
; 688.	                                for (nf = fs->n_fats; nf > 1; nf--) {   /* Reflect the change to all FAT copies */
	LD	HL,2
	ADD	HL,SP
	LD	C,(IY+33)
	LD	B,(IY+34)
	LD	E,(IY+31)
	LD	D,(IY+32)
	CALL	?L_ADDASG_L03
; 689.	                                        wsect += fs->fsize;
	LD	A,(IY+1)
	LD	(dio_par),A
	LD	HL,51
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	(dio_par+1),HL
	LD	HL,2
	ADD	HL,SP
; 690.	                                        SET_DIO_PAR(fs->drv, fs->win, wsect,1);
	CALL	?1036
	DEC	(IX-2)
; 691.	                                        disk_write();
; 692.	                                }
	JR	?0013
?0012:
?0011:
?0007:
; 693.	                        }
; 694.	                }
; 695.	#endif
	LD	A,(IX+8)
	OR	(IX+9)
	OR	(IX+10)
	OR	(IX+11)
	JR	Z,?0017
?0016:
; 696.	                if (sector) {
	LD	A,(IY+1)
	LD	(dio_par),A
	LD	HL,51
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	(dio_par+1),HL
	LD	HL,16
	ADD	HL,SP
; 697.	                        SET_DIO_PAR(fs->drv, fs->win, sector,1);
	CALL	?1041
	JR	Z,?0019
?0018:
; 698.	                        if (disk_read() != RES_OK)
?0922:
	LD	A,1
; 699.	                                return FR_DISK_ERR;
	JR	?0020
?0019:
	LD	C,(IX+10)
	LD	B,(IX+11)
	LD	L,(IX+8)
	LD	(IY+47),L
	LD	H,(IX+9)
	LD	(IY+48),H
	LD	(IY+49),C
	LD	(IY+50),B
?0017:
?0005:
; 700.	                        fs->winsect = sector;
; 701.	                }
; 702.	        }
; 703.	
	XOR	A
; 704.	        return FR_OK;
?0020:
	POP	IY
	JP	?LEAVE_DIRECT_L09
?1038:
	LD	L,(IY+0)
	LD	H,(IY+1)
	INC	HL
	LD	A,(HL)
	LD	(dio_par),A
	LD	HL,32
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	(dio_par+1),HL
	LD	HL,22
?1037:
	ADD	HL,BC
?1036:
	LD	(dio_par+3),HL
	LD	A,1
?1039:
	LD	(dio_par+5),A
	JP	disk_write
?1041:
	LD	(dio_par+3),HL
	LD	A,1
?1042:
	LD	(dio_par+5),A
?1043:
	CALL	disk_read
	OR	A
	RET
; 705.	}
; 706.	
; 707.	
; 708.	
; 709.	
; 710.	/*-----------------------------------------------------------------------*/
; 711.	/* Clean-up cached data                                                  */
; 712.	/*-----------------------------------------------------------------------*/
; 713.	#if !_FS_READONLY
; 714.	static
; 715.	FRESULT sync (  /* FR_OK: successful, FR_DISK_ERR: failed */
; 716.	        FATFS *fs       /* File system object */
; 717.	)
sync:
	PUSH	BC
	PUSH	IY
	PUSH	IX
	PUSH	DE
	POP	IX
; 718.	{
; 719.	        FRESULT res;
; 720.	
; 721.	
	LD	HL,0
	PUSH	HL
	PUSH	HL
	CALL	move_window
	POP	HL
	POP	HL
	LD	IYL,A
; 722.	        res = move_window(fs, 0);
	OR	A
	JP	NZ,?0028
?0021:
; 723.	        if (res == FR_OK) {
; 724.	                /* Update FSInfo sector if needed */
	LD	A,(IX+0)
	CP	3
	JP	NZ,?0024
	LD	A,(IX+6)
	OR	A
	JP	Z,?0024
?0026:
?0025:
?0023:
; 725.	                if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
	XOR	A
	LD	(IX+47),A
	LD	(IX+48),A
	LD	(IX+49),A
	LD	(IX+50),A
; 726.	                        fs->winsect = 0;
; 727.	                        /* Create FSInfo structure */
	LD	BC,512
	LD	HL,51
	PUSH	IX
	POP	DE
	ADD	HL,DE
	EX	DE,HL
	LD	L,C
	LD	H,C
	CALL	?MEMSET_L11
; 728.	                        memset(fs->win, 0, 512);
	LD	L,51
	PUSH	IX
	POP	BC
	ADD	HL,BC
	LD	DE,510
	ADD	HL,DE
	LD	(HL),85
	INC	HL
	LD	(HL),170
; 729.	                        ST_WORD(fs->win+BS_55AA, 0xAA55);
	LD	HL,51
	ADD	HL,BC
	LD	(HL),82
	INC	HL
	LD	(HL),82
	INC	HL
	LD	(HL),97
	INC	HL
	LD	(HL),65
; 730.	                        ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
	LD	HL,51
	ADD	HL,BC
	LD	DE,484
	ADD	HL,DE
	LD	(HL),114
	INC	HL
	LD	(HL),114
	INC	HL
	LD	(HL),65
	INC	HL
	LD	(HL),97
; 731.	                        ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
	LD	HL,51
	ADD	HL,BC
	LD	DE,488
	ADD	HL,DE
	PUSH	HL
	LD	HL,15
	ADD	HL,BC
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	POP	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	LD	(HL),C
	INC	HL
	LD	(HL),B
; 732.	                        ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
	LD	HL,51
	PUSH	IX
	POP	BC
	ADD	HL,BC
	LD	DE,492
	ADD	HL,DE
	PUSH	HL
	LD	HL,11
	ADD	HL,BC
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	POP	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	LD	(HL),C
	INC	HL
	LD	(HL),B
; 733.	                        ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
; 734.	                        /* Write it into the FSInfo sector */
	LD	A,(IX+1)
	LD	(dio_par),A
	LD	HL,51
	PUSH	IX
	POP	BC
	ADD	HL,BC
	LD	(dio_par+1),HL
	LD	HL,19
; 735.	                        SET_DIO_PAR(fs->drv, fs->win, fs->fsi_sector,1);
	CALL	?1037
; 736.	                        disk_write();
	LD	HL,6
	ADD	HL,BC
	LD	(HL),0
?0024:
; 737.	                        fs->fsi_flag = 0;
; 738.	                }
; 739.	                /* Make sure that no pending write process in the physical drive */
	LD	HL,0
	PUSH	HL
	LD	C,H
	LD	E,(IX+1)
	CALL	disk_ioctl
	POP	HL
	OR	A
	JR	Z,?0028
?0027:
; 740.	                if (disk_ioctl(fs->drv, CTRL_SYNC, (void*)0) != RES_OK)
	LD	IYL,1
?0028:
?0022:
; 741.	                        res = FR_DISK_ERR;
; 742.	        }
; 743.	
	LD	A,IYL
; 744.	        return res;
	POP	IX
	POP	IY
	POP	BC
	RET
; 745.	}
; 746.	#endif
; 747.	
; 748.	
; 749.	
; 750.	
; 751.	/*-----------------------------------------------------------------------*/
; 752.	/* Get sector# from cluster#                                             */
; 753.	/*-----------------------------------------------------------------------*/
; 754.	
; 755.	
; 756.	DWORD clust2sect (      /* !=0: Sector number, 0: Failed - invalid cluster# */
; 757.	        FATFS *fs,              /* File system object */
; 758.	        DWORD clst              /* Cluster# to be converted */
; 759.	)
clust2sect:
	PUSH	IX
	PUSH	DE
	POP	IX
; 760.	{
	LD	HL,4
	ADD	HL,SP
	LD	BC,0
	LD	DE,2
	CALL	?L_SUBASG_L03
; 761.	        clst -= 2;
	LD	L,(IX+29)
	LD	H,(IX+30)
	PUSH	HL
	LD	L,(IX+27)
	LD	H,(IX+28)
	PUSH	HL
	LD	HL,65534
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	LD	HL,65535
	POP	BC
	ADC	HL,BC
	PUSH	HL
	PUSH	DE
	LD	HL,8
	ADD	HL,SP
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	L,C
	LD	H,B
	AND	A
	POP	BC
	SBC	HL,BC
	EX	DE,HL
	POP	BC
	SBC	HL,BC
	JR	C,?0030
?0029:
	LD	BC,0
	LD	L,C
	LD	H,B
; 762.	        if (clst >= (fs->n_fatent - 2)) return 0;               /* Invalid cluster# */
	JR	?0031
?0030:
	LD	L,(IX+3)
	LD	BC,0
	LD	H,C
	PUSH	BC
	PUSH	HL
	LD	L,8
	ADD	HL,SP
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	EX	DE,HL
	CALL	?L_MUL_L03
	PUSH	BC
	PUSH	HL
	LD	L,(IX+43)
	LD	H,(IX+44)
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	LD	L,(IX+45)
	LD	H,(IX+46)
	POP	BC
	ADC	HL,BC
	LD	C,L
	LD	B,H
	EX	DE,HL
; 763.	        return clst * fs->csize + fs->database;
?0031:
	POP	IX
	RET
; 764.	}
; 765.	
; 766.	
; 767.	
; 768.	
; 769.	/*-----------------------------------------------------------------------*/
; 770.	/* FAT access - Read value of a FAT entry                                */
; 771.	/*-----------------------------------------------------------------------*/
; 772.	
; 773.	
; 774.	DWORD get_fat ( /* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
; 775.	        FATFS *fs,      /* File system object */
; 776.	        DWORD clst      /* Cluster# to get the link information */
; 777.	)
get_fat:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	-2
	PUSH	IY
	EXX
	PUSH	BC
	PUSH	DE
	EXX
	LD	L,(IX+2)
	LD	H,(IX+3)
	PUSH	HL
	POP	IY
; 778.	{
; 779.	        UINT wc, bc;
; 780.	        BYTE *p;
; 781.	
; 782.	
	AND	A
	LD	L,(IX+8)
	LD	H,(IX+9)
	LD	BC,2
	SBC	HL,BC
	LD	L,(IX+10)
	LD	H,(IX+11)
	DEC	BC
	DEC	BC
	SBC	HL,BC
	JR	C,?0034
	LD	L,(IX+8)
	LD	H,(IX+9)
	LD	C,(IY+27)
	LD	B,(IY+28)
	SBC	HL,BC
	LD	L,(IX+10)
	LD	H,(IX+11)
	LD	C,(IY+29)
	LD	B,(IY+30)
	SBC	HL,BC
	JR	C,?0033
?0034:
?0035:
?0032:
; 783.	        if (clst < 2 || clst >= fs->n_fatent)   /* Chack range */
	LD	BC,0
	LD	HL,1
; 784.	                return 1;
; 785.	
	JP	?0051
?0033:
	LD	A,(IY+0)
	CP	1
	JP	NZ,?0045
?0037:
; 786.	        switch (fs->fs_type) {
; 787.	        case FS_FAT12 :
	EXX
	LD	E,(IX+8)
	LD	D,(IX+9)
	PUSH	DE
	EXX
	POP	BC
	SRL	B
	RR	C
	PUSH	BC
	EXX
	POP	HL
	ADD	HL,DE
	EX	DE,HL
	EXX
; 788.	                bc = (UINT)clst; bc += bc / 2;
	LD	L,(IY+37)
	LD	H,(IY+38)
	PUSH	HL
	LD	L,(IY+35)
	LD	H,(IY+36)
	PUSH	HL
	LD	B,9
	EXX
	PUSH	DE
	EXX
	POP	DE
	CALL	?1044
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	POP	BC
	ADC	HL,BC
	PUSH	HL
	PUSH	DE
	CALL	?1046
	POP	HL
	POP	HL
	OR	A
	JP	NZ,?0036
?0038:
?0039:
; 789.	                if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
	EXX
	PUSH	DE
	EXX
	POP	HL
	LD	A,H
	AND	1
	LD	H,A
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	DE,51
	ADD	HL,DE
	LD	E,(HL)
	PUSH	DE
	EXX
	POP	BC
	INC	DE
	EXX
; 790.	                wc = fs->win[bc % SS(fs)]; bc++;
	LD	HL,35
	ADD	HL,BC
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	PUSH	BC
	PUSH	DE
	LD	B,9
	EXX
	PUSH	DE
	EXX
	POP	DE
	CALL	?1044
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	POP	BC
	ADC	HL,BC
	PUSH	HL
	PUSH	DE
	CALL	?1046
	POP	HL
	POP	HL
	OR	A
	JP	NZ,?0036
?0040:
?0041:
; 791.	                if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
	EXX
	PUSH	DE
	EXX
	POP	HL
	LD	A,H
	AND	1
	LD	H,A
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	BC,51
	ADD	HL,BC
	LD	B,(HL)
	LD	C,0
	PUSH	BC
	EXX
	POP	HL
	LD	A,L
	OR	C
	LD	C,A
	LD	A,H
	OR	B
	LD	B,A
	EXX
; 792.	                wc |= fs->win[bc % SS(fs)] << 8;
	BIT	0,(IX+8)
	JR	Z,?0043
	LD	B,4
	EXX
	PUSH	BC
	EXX
	POP	DE
	CALL	?US_RSH_L02
	EX	DE,HL
	JR	?0925
?0043:
	EXX
	PUSH	BC
	EXX
	POP	HL
	LD	A,H
	AND	15
	LD	H,A
?0925:
	LD	B,C
; 793.	                return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
; 794.	
	JP	?0051
?0045:
	CP	2
	JR	NZ,?0048
; 795.	        case FS_FAT16 :
	LD	L,(IY+37)
	LD	H,(IY+38)
	PUSH	HL
	LD	L,(IY+35)
	LD	H,(IY+36)
	PUSH	HL
	LD	C,(IX+10)
	LD	B,(IX+11)
	LD	L,(IX+9)
	LD	H,C
	LD	E,B
	LD	D,0
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	POP	BC
	ADC	HL,BC
	PUSH	HL
	PUSH	DE
	CALL	?1046
	POP	HL
	POP	HL
	OR	A
	JR	NZ,?0036
?0046:
?0047:
; 796.	                if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
	LD	L,(IX+8)
	LD	H,(IX+9)
	ADD	HL,HL
	LD	A,H
	AND	1
	LD	H,A
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	BC,51
	ADD	HL,BC
; 797.	                p = &fs->win[clst * 2 % SS(fs)];
	LD	B,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,B
	LD	BC,0
; 798.	                return LD_WORD(p);
; 799.	
	JR	?0051
?0048:
	CP	3
	JR	NZ,?0036
; 800.	        case FS_FAT32 :
	LD	L,(IY+37)
	LD	H,(IY+38)
	PUSH	HL
	LD	L,(IY+35)
	LD	H,(IY+36)
	PUSH	HL
	CALL	?1047
	LD	E,C
	LD	D,B
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	POP	BC
	ADC	HL,BC
	PUSH	HL
	PUSH	DE
	CALL	?1046
	POP	HL
	POP	HL
	OR	A
	JR	NZ,?0036
?0049:
?0050:
; 801.	                if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
	LD	L,(IX+8)
	LD	H,(IX+9)
	ADD	HL,HL
	ADD	HL,HL
	LD	A,H
	AND	1
	LD	H,A
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	BC,51
	ADD	HL,BC
; 802.	                p = &fs->win[clst * 4 % SS(fs)];
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	A,(HL)
	EX	DE,HL
	AND	15
	LD	B,A
; 803.	                return LD_DWORD(p) & 0x0FFFFFFF;
	JR	?0051
?0036:
; 804.	        }
; 805.	
	LD	BC,65535
	LD	L,C
	LD	H,B
; 806.	        return 0xFFFFFFFF;      /* An error occurred at the disk I/O layer */
?0051:
	EXX
	POP	DE
	POP	BC
	EXX
	POP	IY
	JP	?LEAVE_32_L09
?1044:
	CALL	?US_RSH_L02
	EX	DE,HL
	LD	DE,0
	RET
?1046:
	PUSH	IY
	POP	DE
	JP	move_window
?1047:
	LD	A,7
?1048:
	LD	C,(IX+10)
	LD	B,(IX+11)
	LD	L,(IX+8)
	LD	H,(IX+9)
	JP	?UL_RSH_L03
; 807.	}
; 808.	
; 809.	
; 810.	
; 811.	
; 812.	/*-----------------------------------------------------------------------*/
; 813.	/* FAT access - Change value of a FAT entry                              */
; 814.	/*-----------------------------------------------------------------------*/
; 815.	#if !_FS_READONLY
; 816.	
; 817.	FRESULT put_fat (
; 818.	        FATFS *fs,      /* File system object */
; 819.	        DWORD clst,     /* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
; 820.	        DWORD val       /* New value to mark the cluster */
; 821.	)
put_fat:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	-2
	PUSH	IY
	EXX
	PUSH	DE
	EXX
	LD	L,(IX+2)
	LD	H,(IX+3)
	PUSH	HL
	POP	IY
; 822.	{
; 823.	        UINT bc;
; 824.	        BYTE *p;
; 825.	        FRESULT res;
; 826.	
; 827.	
	AND	A
	LD	L,(IX+8)
	LD	H,(IX+9)
	LD	BC,2
	SBC	HL,BC
	LD	L,(IX+10)
	LD	H,(IX+11)
	DEC	BC
	DEC	BC
	SBC	HL,BC
	JR	C,?0054
	LD	L,(IX+8)
	LD	H,(IX+9)
	LD	C,(IY+27)
	LD	B,(IY+28)
	SBC	HL,BC
	LD	L,(IX+10)
	LD	H,(IX+11)
	LD	C,(IY+29)
	LD	B,(IY+30)
	SBC	HL,BC
	JR	C,?0053
?0054:
?0055:
?0052:
; 828.	        if (clst < 2 || clst >= fs->n_fatent) { /* Check range */
	LD	(IX-2),2
; 829.	                res = FR_INT_ERR;
; 830.	
	JP	?0056
?0053:
; 831.	        } else {
	LD	A,(IY+0)
	CP	1
	JP	NZ,?0069
?0058:
; 832.	                switch (fs->fs_type) {
; 833.	                case FS_FAT12 :
	EXX
	LD	E,(IX+8)
	LD	D,(IX+9)
	PUSH	DE
	EXX
	POP	BC
	SRL	B
	RR	C
	PUSH	BC
	EXX
	POP	HL
	ADD	HL,DE
	EX	DE,HL
	EXX
; 834.	                        bc = clst; bc += bc / 2;
	LD	L,(IY+37)
	LD	H,(IY+38)
	PUSH	HL
	LD	L,(IY+35)
	LD	H,(IY+36)
	PUSH	HL
	LD	B,9
	EXX
	PUSH	DE
	EXX
	POP	DE
	CALL	?1044
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	POP	BC
	ADC	HL,BC
	PUSH	HL
	PUSH	DE
	CALL	?1046
	POP	HL
	POP	HL
	LD	(IX-2),A
; 835.	                        res = move_window(fs, fs->fatbase + (bc / SS(fs)));
	OR	A
	JP	NZ,?0057
?0059:
?0060:
; 836.	                        if (res != FR_OK) break;
	EXX
	PUSH	DE
	EXX
	POP	HL
	LD	A,H
	AND	1
	LD	H,A
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	BC,51
	ADD	HL,BC
	EX	DE,HL
; 837.	                        p = &fs->win[bc % SS(fs)];
	BIT	0,(IX+8)
	JR	Z,?0062
	LD	L,E
	LD	H,D
	LD	A,(HL)
	AND	15
	PUSH	AF
	LD	A,(IX+12)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	B,A
	POP	AF
	OR	B
	JR	?0063
?0062:
	LD	A,(IX+12)
?0063:
	EX	DE,HL
	LD	(HL),A
; 838.	                        *p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
	EXX
	INC	DE
	EXX
; 839.	                        bc++;
	LD	(IY+5),1
; 840.	                        fs->wflag = 1;
	LD	L,(IY+37)
	LD	H,(IY+38)
	PUSH	HL
	LD	L,(IY+35)
	LD	H,(IY+36)
	PUSH	HL
	LD	B,9
	EXX
	PUSH	DE
	EXX
	POP	DE
	CALL	?1044
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	POP	BC
	ADC	HL,BC
	PUSH	HL
	PUSH	DE
	CALL	?1046
	POP	HL
	POP	HL
	LD	(IX-2),A
; 841.	                        res = move_window(fs, fs->fatbase + (bc / SS(fs)));
	OR	A
	JP	NZ,?0057
?0064:
?0065:
; 842.	                        if (res != FR_OK) break;
	EXX
	PUSH	DE
	EXX
	POP	HL
	LD	A,H
	AND	1
	LD	H,A
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	BC,51
	ADD	HL,BC
	EX	DE,HL
; 843.	                        p = &fs->win[bc % SS(fs)];
	BIT	0,(IX+8)
	JR	Z,?0067
	LD	A,4
	LD	C,(IX+14)
	LD	B,(IX+15)
	LD	L,(IX+12)
	LD	H,(IX+13)
	CALL	?UL_RSH_L03
	LD	A,L
	JR	?0068
?0067:
	LD	L,E
	LD	H,D
	LD	A,(HL)
	AND	240
	PUSH	AF
	LD	A,(IX+13)
	AND	15
	LD	B,A
	POP	AF
	OR	B
?0068:
	EX	DE,HL
	LD	(HL),A
; 844.	                        *p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
	JP	?0057
?0069:
	CP	2
	JR	NZ,?0072
; 845.	                        break;
; 846.	
; 847.	                case FS_FAT16 :
	LD	L,(IY+37)
	LD	H,(IY+38)
	PUSH	HL
	LD	L,(IY+35)
	LD	H,(IY+36)
	PUSH	HL
	LD	C,(IX+10)
	LD	B,(IX+11)
	LD	L,(IX+9)
	LD	H,C
	LD	E,B
	LD	D,0
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	POP	BC
	ADC	HL,BC
	PUSH	HL
	PUSH	DE
	CALL	?1046
	POP	HL
	POP	HL
	LD	(IX-2),A
; 848.	                        res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
	OR	A
	JP	NZ,?0057
?0070:
?0071:
; 849.	                        if (res != FR_OK) break;
	LD	L,(IX+8)
	LD	H,(IX+9)
	ADD	HL,HL
	LD	A,H
	AND	1
	LD	H,A
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	BC,51
	ADD	HL,BC
	EX	DE,HL
; 850.	                        p = &fs->win[clst * 2 % SS(fs)];
	LD	L,(IX+12)
	LD	H,(IX+13)
	PUSH	HL
	EX	DE,HL
	POP	BC
	JR	?0928
; 851.	                        ST_WORD(p, (WORD)val);
?0072:
	CP	3
	JR	NZ,?0075
; 852.	                        break;
; 853.	
; 854.	                case FS_FAT32 :
	LD	L,(IY+37)
	LD	H,(IY+38)
	PUSH	HL
	LD	L,(IY+35)
	LD	H,(IY+36)
	PUSH	HL
	CALL	?1047
	LD	E,C
	LD	D,B
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	POP	BC
	ADC	HL,BC
	PUSH	HL
	PUSH	DE
	CALL	?1046
	POP	HL
	POP	HL
	LD	(IX-2),A
; 855.	                        res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
	OR	A
	JR	NZ,?0057
?0073:
?0074:
; 856.	                        if (res != FR_OK) break;
	LD	L,(IX+8)
	LD	H,(IX+9)
	ADD	HL,HL
	ADD	HL,HL
	LD	A,H
	AND	1
	LD	H,A
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	BC,51
	ADD	HL,BC
	EX	DE,HL
; 857.	                        p = &fs->win[clst * 4 % SS(fs)];
	PUSH	DE
	LD	HL,20
	ADD	HL,SP
	PUSH	HL
	EX	DE,HL
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	E,0
	LD	D,0
	LD	C,B
	AND	240
	LD	B,A
	POP	HL
	CALL	?L_ORASG_L03
	POP	DE
; 858.	                        val |= LD_DWORD(p) & 0xF0000000;
	LD	C,(IX+14)
	LD	B,(IX+15)
	LD	L,(IX+12)
	LD	H,(IX+13)
	PUSH	HL
	EX	DE,HL
	POP	DE
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
?0928:
	LD	(HL),C
	INC	HL
	LD	(HL),B
; 859.	                        ST_DWORD(p, val);
	JR	?0057
?0075:
; 860.	                        break;
; 861.	
; 862.	                default :
	LD	(IX-2),2
?0057:
; 863.	                        res = FR_INT_ERR;
; 864.	                }
	LD	(IY+5),1
?0056:
; 865.	                fs->wflag = 1;
; 866.	        }
; 867.	
	LD	A,(IX-2)
; 868.	        return res;
	EXX
	POP	DE
	EXX
	POP	IY
	JP	?LEAVE_DIRECT_L09
; 869.	}
; 870.	#endif /* !_FS_READONLY */
; 871.	
; 872.	
; 873.	
; 874.	
; 875.	/*-----------------------------------------------------------------------*/
; 876.	/* FAT handling - Remove a cluster chain                                 */
; 877.	/*-----------------------------------------------------------------------*/
; 878.	#if !_FS_READONLY
; 879.	static
; 880.	FRESULT remove_chain (
; 881.	        FATFS *fs,                      /* File system object */
; 882.	        DWORD clst                      /* Cluster# to remove a chain from */
; 883.	)
remove_chain:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	65530
	PUSH	IY
	LD	L,(IX+2)
	LD	H,(IX+3)
	PUSH	HL
	POP	IY
; 884.	{
; 885.	        FRESULT res;
; 886.	        DWORD nxt;
; 887.	#if _USE_ERASE
; 889.	#endif
; 890.	
	AND	A
	LD	L,(IX+8)
	LD	H,(IX+9)
	LD	BC,2
	SBC	HL,BC
	LD	L,(IX+10)
	LD	H,(IX+11)
	DEC	BC
	DEC	BC
	SBC	HL,BC
	JR	C,?0929
	LD	L,(IX+8)
	LD	H,(IX+9)
	LD	C,(IY+27)
	LD	B,(IY+28)
	SBC	HL,BC
	LD	L,(IX+10)
	LD	H,(IX+11)
	LD	C,(IY+29)
	LD	B,(IY+30)
	SBC	HL,BC
	JR	NC,?0929
?0078:
?0079:
?0076:
; 891.	        if (clst < 2 || clst >= fs->n_fatent) { /* Check range */
; 892.	                res = FR_INT_ERR;
; 893.	
?0077:
; 894.	        } else {
	LD	(IX-6),0
?0082:
; 895.	                res = FR_OK;
	AND	A
	LD	L,(IX+8)
	LD	H,(IX+9)
	LD	C,(IY+27)
	LD	B,(IY+28)
	SBC	HL,BC
	LD	L,(IX+10)
	LD	H,(IX+11)
	LD	C,(IY+29)
	LD	B,(IY+30)
	SBC	HL,BC
	JP	NC,?0081
?0083:
; 896.	                while (clst < fs->n_fatent) {                   /* Not a last link? */
	LD	L,(IX+10)
	LD	H,(IX+11)
	PUSH	HL
	LD	L,(IX+8)
	LD	H,(IX+9)
	PUSH	HL
	PUSH	IY
	POP	DE
	CALL	get_fat
	POP	AF
	POP	AF
	LD	(IX-4),L
	LD	(IX-3),H
	LD	(IX-2),C
	LD	(IX-1),B
; 897.	                        nxt = get_fat(fs, clst);                        /* Get cluster status */
	LD	A,L
	OR	H
	OR	C
	OR	B
	JP	Z,?0081
?0084:
?0085:
; 898.	                        if (nxt == 0) break;                            /* Empty cluster? */
	LD	A,1
	XOR	L
	OR	H
	OR	C
	OR	B
	JR	NZ,?0087
?0086:
?0929:
	LD	(IX-6),2
	JR	?0081
?0087:
; 899.	                        if (nxt == 1) { res = FR_INT_ERR; break; }      /* Internal error? */
	LD	A,L
	AND	H
	AND	C
	AND	B
	INC	A
	JR	NZ,?0089
?0088:
	LD	(IX-6),1
	JR	?0081
?0089:
; 900.	                        if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }    /* Disk error? */
	LD	HL,0
	PUSH	HL
	PUSH	HL
	LD	L,(IX+10)
	LD	H,(IX+11)
	PUSH	HL
	LD	L,(IX+8)
	LD	H,(IX+9)
	PUSH	HL
	PUSH	IY
	POP	DE
	CALL	put_fat
	POP	HL
	POP	HL
	POP	HL
	POP	HL
	LD	(IX-6),A
; 901.	                        res = put_fat(fs, clst, 0);                     /* Mark the cluster "empty" */
	OR	A
	JR	NZ,?0081
?0090:
?0091:
; 902.	                        if (res != FR_OK) break;
	LD	A,(IY+15)
	AND	(IY+16)
	AND	(IY+17)
	AND	(IY+18)
	INC	A
	JR	Z,?0093
?0092:
; 903.	                        if (fs->free_clust != 0xFFFFFFFF) {     /* Update FSInfo */
	LD	L,(IY+15)
	LD	H,(IY+16)
	LD	C,(IY+17)
	LD	B,(IY+18)
	CALL	?L_INC_L03
	LD	(IY+15),L
	LD	(IY+16),H
	LD	(IY+17),C
	LD	(IY+18),B
; 904.	                                fs->free_clust++;
	LD	(IY+6),1
?0093:
; 905.	                                fs->fsi_flag = 1;
; 906.	                        }
; 907.	#if _USE_ERASE
; 916.	#endif
	LD	C,(IX-2)
	LD	B,(IX-1)
	LD	L,(IX-4)
	LD	H,(IX-3)
	LD	(IX+8),L
	LD	(IX+9),H
	LD	(IX+10),C
	LD	(IX+11),B
; 917.	                        clst = nxt;     /* Next cluster */
; 918.	                }
	JP	?0082
?0081:
?0080:
; 919.	        }
; 920.	
	LD	A,(IX-6)
; 921.	        return res;
	POP	IY
	JP	?LEAVE_DIRECT_L09
; 922.	}
; 923.	#endif
; 924.	
; 925.	
; 926.	
; 927.	
; 928.	/*-----------------------------------------------------------------------*/
; 929.	/* FAT handling - Stretch or Create a cluster chain                      */
; 930.	/*-----------------------------------------------------------------------*/
; 931.	#if !_FS_READONLY
; 932.	static
; 933.	DWORD create_chain (    /* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
; 934.	        FATFS *fs,                      /* File system object */
; 935.	        DWORD clst                      /* Cluster# to stretch. 0 means create a new chain. */
; 936.	)
create_chain:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	65522
	PUSH	IY
	LD	L,(IX+2)
	LD	H,(IX+3)
	PUSH	HL
	POP	IY
; 937.	{
; 938.	        DWORD cs, ncl, scl;
; 939.	        FRESULT res;
; 940.	
; 941.	
	LD	A,(IX+8)
	OR	(IX+9)
	OR	(IX+10)
	OR	(IX+11)
	JR	NZ,?0095
?0094:
; 942.	        if (clst == 0) {                /* Create a new chain */
	LD	C,(IY+13)
	LD	B,(IY+14)
	LD	L,(IY+11)
	LD	(IX-6),L
	LD	H,(IY+12)
	LD	(IX-5),H
	LD	(IX-4),C
	LD	(IX-3),B
; 943.	                scl = fs->last_clust;                   /* Get suggested start point */
	LD	A,L
	OR	H
	OR	C
	OR	B
	JR	Z,?0098
	LD	C,(IY+27)
	LD	B,(IY+28)
	SBC	HL,BC
	LD	L,(IX-4)
	LD	H,(IX-3)
	LD	C,(IY+29)
	LD	B,(IY+30)
	SBC	HL,BC
	JR	C,?0100
?0098:
?0099:
?0096:
	XOR	A
	LD	(IX-6),1
	LD	(IX-5),A
	LD	(IX-4),A
	LD	(IX-3),A
?0097:
; 944.	                if (!scl || scl >= fs->n_fatent) scl = 1;
; 945.	        }
	JR	?0100
?0095:
; 946.	        else {                                  /* Stretch the current chain */
	LD	L,(IX+10)
	LD	H,(IX+11)
	PUSH	HL
	LD	L,(IX+8)
	LD	H,(IX+9)
	PUSH	HL
	PUSH	IY
	POP	DE
	CALL	get_fat
	POP	AF
	POP	AF
	LD	(IX-10),L
	LD	(IX-9),H
	LD	(IX-8),C
	LD	(IX-7),B
; 947.	                cs = get_fat(fs, clst);                 /* Check the cluster status */
	LD	E,C
	LD	D,B
	AND	A
	LD	BC,2
	SBC	HL,BC
	EX	DE,HL
	DEC	BC
	DEC	BC
	SBC	HL,BC
	JR	NC,?0102
?0101:
	LD	HL,1
; 948.	                if (cs < 2) return 1;                   /* It is an invalid cluster */
	JP	?0131
?0102:
	LD	L,(IX-10)
	LD	H,(IX-9)
	LD	C,(IY+27)
	LD	B,(IY+28)
	SBC	HL,BC
	LD	L,(IX-8)
	LD	H,(IX-7)
	LD	C,(IY+29)
	LD	B,(IY+30)
	SBC	HL,BC
	JP	C,?0115
?0103:
; 949.	                if (cs < fs->n_fatent) return cs;       /* It is already followed by next cluster */
?0104:
	LD	C,(IX+10)
	LD	B,(IX+11)
	LD	L,(IX+8)
	LD	H,(IX+9)
	LD	(IX-6),L
	LD	(IX-5),H
	LD	(IX-4),C
	LD	(IX-3),B
?0100:
; 950.	                scl = clst;
; 951.	        }
; 952.	
	LD	C,(IX-4)
	LD	B,(IX-3)
	LD	L,(IX-6)
	LD	H,(IX-5)
	LD	(IX-14),L
	LD	(IX-13),H
	LD	(IX-12),C
	LD	(IX-11),B
?0106:
; 953.	        ncl = scl;                              /* Start cluster */
; 954.	        for (;;) {
	CALL	?1050
; 955.	                ncl++;                                                  /* Next cluster */
	AND	A
	LD	C,(IY+27)
	LD	B,(IY+28)
	SBC	HL,BC
	LD	L,(IX-12)
	LD	H,(IX-11)
	LD	C,(IY+29)
	LD	B,(IY+30)
	SBC	HL,BC
	JR	C,?0110
?0107:
; 956.	                if (ncl >= fs->n_fatent) {              /* Wrap around */
	XOR	A
	LD	(IX-14),2
	LD	(IX-13),A
	LD	(IX-12),A
	LD	(IX-11),A
; 957.	                        ncl = 2;
	LD	L,(IX-6)
	LD	H,(IX-5)
	LD	BC,2
	SBC	HL,BC
	LD	L,(IX-4)
	LD	H,(IX-3)
	DEC	BC
	DEC	BC
	SBC	HL,BC
	JR	C,?0931
?0109:
; 958.	                        if (ncl > scl) return 0;        /* No free cluster */
?0110:
?0108:
; 959.	                }
	LD	L,(IX-12)
	LD	H,(IX-11)
	PUSH	HL
	LD	L,(IX-14)
	LD	H,(IX-13)
	PUSH	HL
	PUSH	IY
	POP	DE
	CALL	get_fat
	POP	AF
	POP	AF
	LD	(IX-10),L
	LD	(IX-9),H
	LD	(IX-8),C
	LD	(IX-7),B
; 960.	                cs = get_fat(fs, ncl);                  /* Get the cluster status */
	LD	A,L
	OR	H
	OR	C
	OR	B
	JR	Z,?0105
?0111:
?0112:
; 961.	                if (cs == 0) break;                             /* Found a free cluster */
	LD	A,L
	AND	H
	AND	C
	AND	B
	INC	A
	JR	Z,?0115
	LD	A,1
	XOR	L
	OR	H
	OR	C
	OR	B
	JR	NZ,?0114
?0115:
?0116:
?0113:
; 962.	                if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
	LD	C,(IX-8)
	LD	B,(IX-7)
	LD	L,(IX-10)
	LD	H,(IX-9)
; 963.	                        return cs;
	JP	?0131
?0114:
	LD	L,(IX-14)
	LD	H,(IX-13)
	LD	C,(IX-6)
	LD	B,(IX-5)
	SBC	HL,BC
	JR	NZ,?0118
	LD	L,(IX-12)
	LD	H,(IX-11)
	LD	C,(IX-4)
	LD	B,(IX-3)
	SBC	HL,BC
	JR	NZ,?0118
?0117:
?0931:
	LD	BC,0
	LD	L,C
	LD	H,B
; 964.	                if (ncl == scl) return 0;               /* No free cluster */
	JP	?0131
?0118:
; 965.	        }
; 966.	
	JP	?0106
?0105:
	LD	HL,4095
	PUSH	HL
	LD	H,L
	PUSH	HL
	LD	L,(IX-12)
	LD	H,(IX-11)
	PUSH	HL
	LD	L,(IX-14)
	LD	H,(IX-13)
	PUSH	HL
	PUSH	IY
	POP	DE
	CALL	put_fat
	POP	HL
	POP	HL
	POP	HL
	POP	HL
	LD	(IX-2),A
; 967.	        res = put_fat(fs, ncl, 0x0FFFFFFF);     /* Mark the new cluster "last link" */
	OR	A
	JR	NZ,?0120
	LD	A,(IX+8)
	OR	(IX+9)
	OR	(IX+10)
	OR	(IX+11)
	JR	Z,?0120
?0122:
?0121:
?0119:
; 968.	        if (res == FR_OK && clst != 0) {
	LD	L,(IX-12)
	LD	H,(IX-11)
	PUSH	HL
	LD	L,(IX-14)
	LD	H,(IX-13)
	PUSH	HL
	LD	L,(IX+10)
	LD	H,(IX+11)
	PUSH	HL
	LD	L,(IX+8)
	LD	H,(IX+9)
	PUSH	HL
	PUSH	IY
	POP	DE
	CALL	put_fat
	POP	HL
	POP	HL
	POP	HL
	POP	HL
	LD	(IX-2),A
?0120:
; 969.	                res = put_fat(fs, clst, ncl);   /* Link it to the previous one if needed */
; 970.	        }
	XOR	A
	OR	(IX-2)
	JR	NZ,?0124
?0123:
; 971.	        if (res == FR_OK) {
	LD	C,(IX-12)
	LD	B,(IX-11)
	LD	L,(IX-14)
	LD	(IY+11),L
	LD	H,(IX-13)
	LD	(IY+12),H
	LD	(IY+13),C
	LD	(IY+14),B
; 972.	                fs->last_clust = ncl;                   /* Update FSINFO */
	LD	A,(IY+15)
	AND	(IY+16)
	AND	(IY+17)
	AND	(IY+18)
	INC	A
	JR	Z,?0127
?0125:
; 973.	                if (fs->free_clust != 0xFFFFFFFF) {
	LD	L,(IY+15)
	LD	H,(IY+16)
	LD	C,(IY+17)
	LD	B,(IY+18)
	CALL	?L_DEC_L03
	LD	(IY+15),L
	LD	(IY+16),H
	LD	(IY+17),C
	LD	(IY+18),B
; 974.	                        fs->free_clust--;
	LD	(IY+6),1
?0126:
; 975.	                        fs->fsi_flag = 1;
; 976.	                }
	JR	?0127
?0124:
; 977.	        } else {
	LD	B,A
	DEC	B
	JR	NZ,?0129
	LD	BC,65535
	LD	L,C
	LD	H,B
	JR	?0130
?0129:
	LD	BC,0
	LD	HL,1
?0130:
	LD	(IX-14),L
	LD	(IX-13),H
	LD	(IX-12),C
	LD	(IX-11),B
?0127:
; 978.	                ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
; 979.	        }
; 980.	
	LD	C,(IX-12)
	LD	B,(IX-11)
	LD	L,(IX-14)
	LD	H,(IX-13)
; 981.	        return ncl;             /* Return new cluster number or error code */
?0131:
	POP	IY
	JP	?LEAVE_32_L09
?1050:
	LD	L,(IX-14)
	LD	H,(IX-13)
	LD	C,(IX-12)
	LD	B,(IX-11)
	CALL	?L_INC_L03
	LD	(IX-14),L
	LD	(IX-13),H
	LD	(IX-12),C
	LD	(IX-11),B
	RET
; 982.	}
; 983.	#endif /* !_FS_READONLY */
; 984.	
; 985.	
; 986.	
; 987.	/*-----------------------------------------------------------------------*/
; 988.	/* FAT handling - Convert offset into cluster with link map table        */
; 989.	/*-----------------------------------------------------------------------*/
; 990.	
; 991.	#if _USE_FASTSEEK
; 1011.	#endif  /* _USE_FASTSEEK */
; 1012.	
; 1013.	
; 1014.	
; 1015.	/*-----------------------------------------------------------------------*/
; 1016.	/* Directory handling - Set directory index                              */
; 1017.	/*-----------------------------------------------------------------------*/
; 1018.	
; 1019.	static
; 1020.	FRESULT dir_sdi (
; 1021.	        DIR *dj,                /* Pointer to directory object */
; 1022.	        WORD idx                /* Directory index number */
; 1023.	)
dir_sdi:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	-4
	PUSH	IY
	EXX
	PUSH	BC
	PUSH	DE
	EXX
	PUSH	BC
	EXX
	POP	DE
	EXX
	LD	L,(IX+2)
	LD	H,(IX+3)
	PUSH	HL
	POP	IY
; 1024.	{
; 1025.	        DWORD clst;
; 1026.	        WORD ic;
; 1027.	
; 1028.	
	LD	(IY+4),C
	LD	(IY+5),B
; 1029.	        dj->index = idx;
	LD	C,(IY+8)
	LD	B,(IY+9)
	LD	L,(IY+6)
	LD	(IX-4),L
	LD	H,(IY+7)
	LD	(IX-3),H
	LD	(IX-2),C
	LD	(IX-1),B
; 1030.	        clst = dj->sclust;
	LD	A,1
	XOR	L
	OR	H
	OR	C
	OR	B
	JR	Z,?0134
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	BC,27
	ADD	HL,BC
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	PUSH	DE
	PUSH	BC
	AND	A
	LD	L,(IX-4)
	LD	H,(IX-3)
	POP	BC
	SBC	HL,BC
	LD	L,(IX-2)
	LD	H,(IX-1)
	POP	BC
	SBC	HL,BC
	JR	C,?0133
?0134:
?0135:
?0132:
; 1031.	        if (clst == 1 || clst >= dj->fs->n_fatent)      /* Check start cluster range */
	JR	?0933
; 1032.	                return FR_INT_ERR;
?0133:
	LD	A,(IX-4)
	OR	(IX-3)
	OR	(IX-2)
	OR	(IX-1)
	JR	NZ,?0137
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	A,(HL)
	CP	3
	JR	NZ,?0137
?0139:
?0138:
?0136:
; 1033.	        if (!clst && dj->fs->fs_type == FS_FAT32)       /* Replace cluster# 0 with root cluster# if in FAT32 */
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	BC,39
	ADD	HL,BC
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	EX	DE,HL
	LD	(IX-4),L
	LD	(IX-3),H
	LD	(IX-2),C
	LD	(IX-1),B
?0137:
; 1034.	                clst = dj->fs->dirbase;
; 1035.	
	LD	A,(IX-4)
	OR	(IX-3)
	OR	(IX-2)
	OR	(IX-1)
	JR	NZ,?0141
?0140:
; 1036.	        if (clst == 0) {        /* Static table (root-dir in FAT12/16) */
	LD	C,(IX-2)
	LD	B,(IX-1)
	LD	L,(IX-4)
	LD	(IY+10),L
	LD	H,(IX-3)
	LD	(IY+11),H
	LD	(IY+12),C
	LD	(IY+13),B
; 1037.	                dj->clust = clst;
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	BC,9
	ADD	HL,BC
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	EXX
	PUSH	DE
	EXX
	POP	HL
	AND	A
	SBC	HL,BC
	JR	C,?0143
?0142:
; 1038.	                if (idx >= dj->fs->n_rootdir)           /* Index is out of range */
?0933:
	JP	?0152
; 1039.	                        return FR_INT_ERR;
?0143:
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	BC,39
	ADD	HL,BC
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	PUSH	DE
	PUSH	BC
	JP	?0932
; 1040.	                dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);       /* Sector# */
; 1041.	        }
?0141:
; 1042.	        else {                          /* Dynamic table (sub-dirs or root-dir in FAT32) */
	LD	L,(IY+0)
	LD	H,(IY+1)
	INC	HL
	INC	HL
	INC	HL
	LD	L,(HL)
	LD	H,0
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	PUSH	HL
	EXX
	POP	BC
?0935:
?0146:
; 1043.	                ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;       /* Entries per cluster */
	PUSH	BC
	EXX
	POP	BC
	EXX
	PUSH	DE
	EXX
	POP	HL
	AND	A
	SBC	HL,BC
	JR	C,?0145
?0147:
; 1044.	                while (idx >= ic) {     /* Follow cluster chain */
	LD	L,(IX-2)
	LD	H,(IX-1)
	PUSH	HL
	LD	L,(IX-4)
	LD	H,(IX-3)
	PUSH	HL
	CALL	?1049
	POP	AF
	POP	AF
	LD	(IX-4),L
	LD	(IX-3),H
	LD	(IX-2),C
	LD	(IX-1),B
; 1045.	                        clst = get_fat(dj->fs, clst);                           /* Get next cluster */
	LD	A,L
	AND	H
	AND	C
	AND	B
	INC	A
	JR	NZ,?0149
?0148:
	LD	A,1
; 1046.	                        if (clst == 0xFFFFFFFF) return FR_DISK_ERR;     /* Disk error */
	JP	?0154
?0149:
	LD	BC,2
	SBC	HL,BC
	LD	L,(IX-2)
	LD	H,(IX-1)
	DEC	BC
	DEC	BC
	SBC	HL,BC
	JR	C,?0152
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	C,27
	ADD	HL,BC
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	PUSH	DE
	PUSH	BC
	AND	A
	LD	L,(IX-4)
	LD	H,(IX-3)
	POP	BC
	SBC	HL,BC
	LD	L,(IX-2)
	LD	H,(IX-1)
	POP	BC
	SBC	HL,BC
	JR	C,?0151
?0152:
?0153:
?0150:
; 1047.	                        if (clst < 2 || clst >= dj->fs->n_fatent)       /* Reached to end of table or int error */
	LD	A,2
; 1048.	                                return FR_INT_ERR;
	JR	?0154
?0151:
	EXX
	PUSH	BC
	EX	DE,HL
	POP	DE
	AND	A
	SBC	HL,DE
	EX	DE,HL
	JR	?0935
; 1049.	                        idx -= ic;
; 1050.	                }
?0145:
	LD	C,(IX-2)
	LD	B,(IX-1)
	LD	L,(IX-4)
	LD	(IY+10),L
	LD	H,(IX-3)
	LD	(IY+11),H
	LD	(IY+12),C
	LD	(IY+13),B
; 1051.	                dj->clust = clst;
	LD	L,C
	LD	H,B
	PUSH	BC
	LD	L,(IX-4)
	LD	H,(IX-3)
	PUSH	HL
	CALL	?1052
	POP	AF
	POP	AF
	PUSH	BC
	PUSH	HL
?0932:
	LD	B,4
	EXX
	PUSH	DE
	EXX
	POP	DE
	CALL	?1044
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	POP	BC
	ADC	HL,BC
	LD	C,L
	LD	B,H
	EX	DE,HL
	LD	(IY+14),L
	LD	(IY+15),H
	LD	(IY+16),C
	LD	(IY+17),B
?0144:
; 1052.	                dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);      /* Sector# */
; 1053.	        }
; 1054.	
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	BC,51
	ADD	HL,BC
	PUSH	HL
	EXX
	PUSH	DE
	EXX
	POP	BC
	LD	A,C
	AND	15
	LD	L,A
	LD	H,0
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	C,L
	LD	B,H
	POP	HL
	ADD	HL,BC
	LD	(IY+18),L
	LD	(IY+19),H
; 1055.	        dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR; /* Ptr to the entry in the sector */
; 1056.	
	XOR	A
; 1057.	        return FR_OK;   /* Seek succeeded */
?0154:
	EXX
	POP	DE
	POP	BC
	EXX
	POP	IY
	JP	?LEAVE_DIRECT_L09
?1049:
	LD	E,(IY+0)
	LD	D,(IY+1)
	JP	get_fat
?1052:
	LD	E,(IY+0)
	LD	D,(IY+1)
	JP	clust2sect
; 1058.	}
; 1059.	
; 1060.	
; 1061.	
; 1062.	
; 1063.	/*-----------------------------------------------------------------------*/
; 1064.	/* Directory handling - Move directory index next                        */
; 1065.	/*-----------------------------------------------------------------------*/
; 1066.	
; 1067.	static
; 1068.	FRESULT dir_next (      /* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
; 1069.	        DIR *dj,                /* Pointer to directory object */
; 1070.	        int stretch             /* 0: Do not stretch table, 1: Stretch table if needed */
; 1071.	)
dir_next:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	65528
	PUSH	IY
	EXX
	PUSH	BC
	EXX
	LD	L,(IX+2)
	LD	H,(IX+3)
	PUSH	HL
	POP	IY
; 1072.	{
; 1073.	        DWORD clst;
; 1074.	        WORD i;
; 1075.	
; 1076.	
	LD	L,(IY+4)
	LD	H,(IY+5)
	INC	HL
	PUSH	HL
	EXX
	POP	BC
	EXX
; 1077.	        i = dj->index + 1;
	LD	A,L
	OR	H
	JR	Z,?0939
	LD	A,(IY+14)
	OR	(IY+15)
	OR	(IY+16)
	OR	(IY+17)
	JR	Z,?0939
?0157:
?0158:
?0155:
; 1078.	        if (!i || !dj->sect)    /* Report EOT when index has reached 65535 */
; 1079.	                return FR_NO_FILE;
; 1080.	
?0156:
	LD	A,L
	AND	15
	JP	NZ,?0167
?0159:
; 1081.	        if (!(i % (SS(dj->fs) / SZ_DIR))) {     /* Sector changed? */
	LD	L,(IY+14)
	LD	H,(IY+15)
	LD	C,(IY+16)
	LD	B,(IY+17)
	CALL	?L_INC_L03
	LD	(IY+14),L
	LD	(IY+15),H
	LD	(IY+16),C
	LD	(IY+17),B
; 1082.	                dj->sect++;                                     /* Next sector */
; 1083.	
	LD	A,(IY+10)
	OR	(IY+11)
	OR	(IY+12)
	OR	(IY+13)
	JR	NZ,?0162
?0161:
; 1084.	                if (dj->clust == 0) {   /* Static table */
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	BC,9
	ADD	HL,BC
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	EXX
	PUSH	BC
	EXX
	POP	HL
	AND	A
	SBC	HL,BC
	JR	C,?0164
?0163:
; 1085.	                        if (i >= dj->fs->n_rootdir)     /* Report EOT when end of table */
?0939:
	JP	?0940
; 1086.	                                return FR_NO_FILE;
?0164:
; 1087.	                }
	JP	?0167
?0162:
; 1088.	                else {                                  /* Dynamic table */
	LD	B,4
	EXX
	PUSH	BC
	EXX
	POP	DE
	CALL	?US_RSH_L02
	LD	L,(IY+0)
	LD	H,(IY+1)
	INC	HL
	INC	HL
	INC	HL
	LD	C,(HL)
	LD	B,0
	DEC	BC
	LD	A,E
	AND	C
	LD	H,A
	LD	A,D
	AND	B
	OR	H
	JP	NZ,?0167
?0166:
; 1089.	                        if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) { /* Cluster changed? */
	LD	L,(IY+12)
	LD	H,(IY+13)
	PUSH	HL
	LD	L,(IY+10)
	LD	H,(IY+11)
	PUSH	HL
	CALL	?1049
	POP	AF
	POP	AF
	LD	(IX-8),L
	LD	(IX-7),H
	LD	(IX-6),C
	LD	(IX-5),B
; 1090.	                                clst = get_fat(dj->fs, dj->clust);                              /* Get next cluster */
	PUSH	BC
	PUSH	HL
	AND	A
	LD	HL,1
	POP	BC
	SBC	HL,BC
	LD	HL,0
	POP	BC
	SBC	HL,BC
	JR	NC,?0941
?0168:
; 1091.	                                if (clst <= 1) return FR_INT_ERR;
?0169:
	LD	A,(IX-8)
	AND	(IX-7)
	AND	(IX-6)
	AND	(IX-5)
	INC	A
	JP	Z,?0944
?0170:
; 1092.	                                if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
?0171:
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	BC,27
	ADD	HL,BC
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	PUSH	DE
	PUSH	BC
	AND	A
	LD	L,(IX-8)
	LD	H,(IX-7)
	POP	BC
	SBC	HL,BC
	LD	L,(IX-6)
	LD	H,(IX-5)
	POP	BC
	SBC	HL,BC
	JP	C,?0173
?0172:
; 1093.	                                if (clst >= dj->fs->n_fatent) {                                 /* When it reached end of dynamic table */
; 1094.	#if !_FS_READONLY
; 1095.	                                        BYTE c;
	LD	A,(IX+4)
	OR	(IX+5)
	JR	NZ,?0175
?0174:
?0940:
	LD	A,4
; 1096.	                                        if (!stretch) return FR_NO_FILE;                        /* When do not stretch, report EOT */
	JP	?0190
?0175:
	LD	L,(IY+12)
	LD	H,(IY+13)
	PUSH	HL
	LD	L,(IY+10)
	LD	H,(IY+11)
	PUSH	HL
	CALL	?1053
	POP	AF
	POP	AF
	LD	(IX-8),L
	LD	(IX-7),H
	LD	(IX-6),C
	LD	(IX-5),B
; 1097.	                                        clst = create_chain(dj->fs, dj->clust);         /* Stretch cluster chain */
	LD	A,L
	OR	H
	OR	C
	OR	B
	JR	NZ,?0177
?0176:
	LD	A,7
; 1098.	                                        if (clst == 0) return FR_DENIED;                        /* No free cluster */
	JP	?0190
?0177:
	LD	A,1
	XOR	L
	OR	H
	OR	C
	OR	B
	JR	NZ,?0179
?0178:
?0941:
	LD	A,2
; 1099.	                                        if (clst == 1) return FR_INT_ERR;
	JP	?0190
?0179:
	LD	A,L
	AND	H
	AND	C
	AND	B
	INC	A
	JR	Z,?0943
?0180:
; 1100.	                                        if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
; 1101.	                                        /* Clean-up stretched table */
?0181:
	LD	HL,0
	PUSH	HL
	PUSH	HL
	LD	E,(IY+0)
	LD	D,(IY+1)
	CALL	move_window
	POP	HL
	POP	HL
	OR	A
	JR	Z,?0183
?0182:
?0943:
	JR	?0944
; 1102.	                                        if (move_window(dj->fs, 0)) return FR_DISK_ERR; /* Flush active window */
?0183:
	LD	BC,512
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	DE,51
	ADD	HL,DE
	EX	DE,HL
	LD	L,C
	CALL	?MEMSET_L11
; 1103.	                                        memset(dj->fs->win, 0, SS(dj->fs));                     /* Clear window buffer */
	LD	L,(IX-6)
	LD	H,(IX-5)
	PUSH	HL
	LD	L,(IX-8)
	LD	H,(IX-7)
	PUSH	HL
	CALL	?1052
	POP	AF
	POP	AF
	PUSH	HL
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	DE,47
	ADD	HL,DE
	POP	DE
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	LD	(HL),C
	INC	HL
	LD	(HL),B
; 1104.	                                        dj->fs->winsect = clust2sect(dj->fs, clst);     /* Cluster start sector */
	LD	(IX-2),0
?0185:
	LD	L,(IY+0)
	LD	H,(IY+1)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(IX-2)
	CP	(HL)
	LD	L,(IY+0)
	LD	H,(IY+1)
	JR	NC,?0184
?0186:
; 1105.	                                        for (c = 0; c < dj->fs->csize; c++) {           /* Fill the new cluster with 0 */
	LD	BC,5
	ADD	HL,BC
	LD	(HL),1
; 1106.	                                                dj->fs->wflag = 1;
	LD	L,B
	LD	H,B
	PUSH	HL
	PUSH	HL
	LD	E,(IY+0)
	LD	D,(IY+1)
	CALL	move_window
	POP	HL
	POP	HL
	OR	A
	JR	Z,?0189
?0188:
?0944:
	LD	A,1
; 1107.	                                                if (move_window(dj->fs, 0)) return FR_DISK_ERR;
	JR	?0190
?0189:
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	C,47
	ADD	HL,BC
	CALL	?L_INCASG_L03
	INC	(IX-2)
; 1108.	                                                dj->fs->winsect++;
; 1109.	                                        }
	JR	?0185
?0184:
	LD	BC,47
	ADD	HL,BC
	LD	E,A
	LD	C,B
	LD	D,C
	CALL	?L_SUBASG_L03
?0173:
; 1110.	                                        dj->fs->winsect -= c;                                           /* Rewind window address */
; 1111.	#else
; 1113.	#endif
; 1114.	                                }
	LD	C,(IX-6)
	LD	B,(IX-5)
	LD	L,(IX-8)
	LD	(IY+10),L
	LD	H,(IX-7)
	LD	(IY+11),H
	LD	(IY+12),C
	LD	(IY+13),B
; 1115.	                                dj->clust = clst;                               /* Initialize data for new cluster */
	LD	L,C
	LD	H,B
	PUSH	BC
	LD	L,(IX-8)
	LD	H,(IX-7)
	PUSH	HL
	CALL	?1052
	POP	AF
	POP	AF
	LD	(IY+14),L
	LD	(IY+15),H
	LD	(IY+16),C
	LD	(IY+17),B
?0167:
?0165:
?0160:
; 1116.	                                dj->sect = clust2sect(dj->fs, clst);
; 1117.	                        }
; 1118.	                }
; 1119.	        }
; 1120.	
	EXX
	PUSH	BC
	EXX
	POP	HL
	LD	(IY+4),L
	LD	(IY+5),H
; 1121.	        dj->index = i;
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	BC,51
	ADD	HL,BC
	PUSH	HL
	EXX
	PUSH	BC
	EXX
	POP	BC
	LD	A,C
	AND	15
	LD	L,A
	LD	H,0
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	C,L
	LD	B,H
	POP	HL
	ADD	HL,BC
	LD	(IY+18),L
	LD	(IY+19),H
; 1122.	        dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
; 1123.	
	XOR	A
; 1124.	        return FR_OK;
?0190:
	EXX
	POP	BC
	EXX
	POP	IY
	JP	?LEAVE_DIRECT_L09
?1053:
	LD	E,(IY+0)
	LD	D,(IY+1)
	JP	create_chain
; 1125.	}
; 1126.	
; 1127.	
; 1128.	
; 1129.	
; 1130.	/*-----------------------------------------------------------------------*/
; 1131.	/* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
; 1132.	/*-----------------------------------------------------------------------*/
; 1133.	#if _USE_LFN
; 1201.	#if !_FS_READONLY
; 1230.	#endif
; 1231.	#endif
; 1232.	
; 1233.	
; 1234.	
; 1235.	/*-----------------------------------------------------------------------*/
; 1236.	/* Create numbered name                                                  */
; 1237.	/*-----------------------------------------------------------------------*/
; 1238.	#if _USE_LFN
; 1277.	#endif
; 1278.	
; 1279.	
; 1280.	
; 1281.	
; 1282.	/*-----------------------------------------------------------------------*/
; 1283.	/* Calculate sum of an SFN                                               */
; 1284.	/*-----------------------------------------------------------------------*/
; 1285.	#if _USE_LFN
; 1297.	#endif
; 1298.	
; 1299.	
; 1300.	
; 1301.	
; 1302.	/*-----------------------------------------------------------------------*/
; 1303.	/* Directory handling - Find an object in the directory                  */
; 1304.	/*-----------------------------------------------------------------------*/
; 1305.	
; 1306.	static
; 1307.	FRESULT dir_find (
; 1308.	        DIR *dj                 /* Pointer to the directory object linked to the file name */
; 1309.	)
dir_find:
	PUSH	BC
	PUSH	IY
	PUSH	IX
	EXX
	PUSH	BC
	EXX
	PUSH	AF
; 1310.	{
; 1311.	        FRESULT res;
; 1312.	        BYTE c, *dir;
; 1313.	#if _USE_LFN
; 1315.	#endif
; 1316.	
	CALL	?1054
; 1317.	        res = dir_sdi(dj, 0);                   /* Rewind directory object */
	JR	NZ,?0193
?0191:
; 1318.	        if (res != FR_OK) return res;
; 1319.	
; 1320.	#if _USE_LFN
; 1322.	#endif
?0192:
?0195:
; 1323.	        do {
	LD	L,(IX+16)
	LD	H,(IX+17)
	PUSH	HL
	LD	L,(IX+14)
	LD	H,(IX+15)
	PUSH	HL
	CALL	?1045
	POP	HL
	POP	HL
	LD	IYL,A
; 1324.	                res = move_window(dj->fs, dj->sect);
	OR	A
	JR	NZ,?0193
?0196:
?0197:
; 1325.	                if (res != FR_OK) break;
	EXX
	LD	C,(IX+18)
	LD	B,(IX+19)
; 1326.	                dir = dj->dir;                                  /* Ptr to the directory entry of current index */
	PUSH	BC
	EXX
	POP	HL
	LD	B,(HL)
; 1327.	                c = dir[DIR_Name];
	OR	B
	JR	NZ,?0199
?0198:
	LD	IYL,4
	JR	?0193
?0199:
; 1328.	                if (c == 0) { res = FR_NO_FILE; break; }        /* Reached to end of table */
; 1329.	#if _USE_LFN    /* LFN configuration */
; 1350.	#else           /* Non LFN configuration */
	LD	HL,11
	EXX
	PUSH	BC
	EXX
	POP	BC
	ADD	HL,BC
	BIT	3,(HL)
	JR	NZ,?0201
	LD	BC,11
	EXX
	PUSH	BC
	EXX
	POP	DE
	LD	L,(IX+20)
	LD	H,(IX+21)
	CALL	?MEMCMP_L11
	LD	A,L
	OR	H
	JR	Z,?0193
?0203:
?0202:
?0200:
; 1351.	                if (!(dir[DIR_Attr] & AM_VOL) && !memcmp(dir, dj->fn, 11)) /* Is it a valid entry? */
?0201:
; 1352.	                        break;
; 1353.	#endif
	CALL	?1056
; 1354.	                res = dir_next(dj, 0);          /* Next entry */
	JR	Z,?0192
?0193:
; 1355.	        } while (res == FR_OK);
; 1356.	
	LD	A,IYL
; 1357.	        return res;
?0204:
	POP	HL
?1034:
	EXX
	POP	BC
	EXX
	POP	IX
	POP	IY
	POP	BC
	RET
?1045:
	LD	E,(IX+0)
	LD	D,(IX+1)
	JP	move_window
?1054:
	PUSH	DE
	POP	IX
	LD	BC,0
?1055:
	CALL	dir_sdi
	LD	IYL,A
	OR	A
	RET
?1056:
	LD	BC,0
?1057:
	PUSH	IX
	POP	DE
	CALL	dir_next
	LD	IYL,A
	OR	A
	RET
; 1358.	}
; 1359.	
; 1360.	
; 1361.	
; 1362.	
; 1363.	/*-----------------------------------------------------------------------*/
; 1364.	/* Read an object from the directory                                     */
; 1365.	/*-----------------------------------------------------------------------*/
; 1366.	#if _FS_MINIMIZE <= 1
; 1367.	static
; 1368.	FRESULT dir_read (
; 1369.	        DIR *dj                 /* Pointer to the directory object that pointing the entry to be read */
; 1370.	)
dir_read:
	PUSH	BC
	PUSH	IY
	PUSH	IX
	EXX
	PUSH	BC
	EXX
	PUSH	DE
	POP	IX
; 1371.	{
; 1372.	        FRESULT res;
; 1373.	        BYTE c, *dir;
; 1374.	#if _USE_LFN
; 1376.	#endif
; 1377.	
	LD	IYL,4
?0206:
; 1378.	        res = FR_NO_FILE;
	LD	A,(IX+14)
	OR	(IX+15)
	OR	(IX+16)
	OR	(IX+17)
	JR	Z,?0205
?0207:
; 1379.	        while (dj->sect) {
	LD	L,(IX+16)
	LD	H,(IX+17)
	PUSH	HL
	LD	L,(IX+14)
	LD	H,(IX+15)
	PUSH	HL
	CALL	?1045
	POP	HL
	POP	HL
	LD	IYL,A
; 1380.	                res = move_window(dj->fs, dj->sect);
	OR	A
	JR	NZ,?0205
?0208:
?0209:
; 1381.	                if (res != FR_OK) break;
	EXX
	LD	C,(IX+18)
	LD	B,(IX+19)
; 1382.	                dir = dj->dir;                                  /* Ptr to the directory entry of current index */
	PUSH	BC
	EXX
	POP	HL
	LD	B,(HL)
	LD	IYH,B
; 1383.	                c = dir[DIR_Name];
	INC	B
	DEC	B
	JR	NZ,?0211
?0210:
	LD	IYL,4
	JR	?0205
?0211:
; 1384.	                if (c == 0) { res = FR_NO_FILE; break; }        /* Reached to end of table */
; 1385.	#if _USE_LFN    /* LFN configuration */
; 1404.	#else           /* Non LFN configuration */
	LD	A,IYH
	CP	229
	JR	Z,?0213
?0216:
?0217:
	LD	HL,11
	EXX
	PUSH	BC
	EXX
	POP	BC
	ADD	HL,BC
	BIT	3,(HL)
	JR	Z,?0205
?0215:
?0214:
?0212:
; 1405.	                if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))   /* Is it a valid entry? */
?0213:
; 1406.	                        break;
; 1407.	#endif
	CALL	?1056
; 1408.	                res = dir_next(dj, 0);                          /* Next entry */
	JR	Z,?0206
?0218:
?0219:
; 1409.	                if (res != FR_OK) break;
; 1410.	        }
; 1411.	
?0205:
	LD	B,IYL
	INC	B
	DEC	B
	JR	Z,?0221
?0220:
	XOR	A
	LD	(IX+14),A
	LD	(IX+15),A
	LD	(IX+16),A
	LD	(IX+17),A
?0221:
; 1412.	        if (res != FR_OK) dj->sect = 0;
; 1413.	
	LD	A,IYL
; 1414.	        return res;
	JP	?1034
; 1415.	}
; 1416.	#endif
; 1417.	
; 1418.	
; 1419.	
; 1420.	/*-----------------------------------------------------------------------*/
; 1421.	/* Register an object to the directory                                   */
; 1422.	/*-----------------------------------------------------------------------*/
; 1423.	#if !_FS_READONLY
; 1424.	static
; 1425.	FRESULT dir_register (  /* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
; 1426.	        DIR *dj                         /* Target directory with object name to be created */
; 1427.	)
dir_register:
	PUSH	BC
	PUSH	IY
	PUSH	IX
	EXX
	PUSH	BC
	EXX
	PUSH	AF
; 1428.	{
; 1429.	        FRESULT res;
; 1430.	        BYTE c, *dir;
; 1431.	#if _USE_LFN    /* LFN configuration */
; 1494.	#else   /* Non LFN configuration */
	CALL	?1054
; 1495.	        res = dir_sdi(dj, 0);
	JR	NZ,?0224
?0222:
?0226:
; 1496.	        if (res == FR_OK) {
; 1497.	                do {    /* Find a blank entry for the SFN */
	LD	L,(IX+16)
	LD	H,(IX+17)
	PUSH	HL
	LD	L,(IX+14)
	LD	H,(IX+15)
	PUSH	HL
	CALL	?1045
	POP	HL
	POP	HL
	LD	IYL,A
; 1498.	                        res = move_window(dj->fs, dj->sect);
	OR	A
	JR	NZ,?0224
?0227:
?0228:
; 1499.	                        if (res != FR_OK) break;
	LD	L,(IX+18)
	LD	H,(IX+19)
	LD	B,(HL)
	LD	A,B
; 1500.	                        c = *dj->dir;
	CP	229
	JR	Z,?0224
	XOR	A
	OR	B
	JR	Z,?0224
?0231:
?0232:
?0229:
?0230:
; 1501.	                        if (c == DDE || c == 0) break;  /* Is it a blank entry? */
	LD	BC,1
	CALL	?1057
; 1502.	                        res = dir_next(dj, 1);                  /* Next entry with table stretch */
	JR	Z,?0222
?0224:
?0223:
; 1503.	                } while (res == FR_OK);
; 1504.	        }
; 1505.	#endif
; 1506.	
	LD	B,IYL
	INC	B
	DEC	B
	JR	NZ,?0236
?0233:
; 1507.	        if (res == FR_OK) {             /* Initialize the SFN entry */
	LD	L,(IX+16)
	LD	H,(IX+17)
	PUSH	HL
	LD	L,(IX+14)
	LD	H,(IX+15)
	PUSH	HL
	CALL	?1045
	POP	HL
	POP	HL
	LD	IYL,A
; 1508.	                res = move_window(dj->fs, dj->sect);
	OR	A
	JR	NZ,?0236
?0235:
; 1509.	                if (res == FR_OK) {
	EXX
	LD	C,(IX+18)
	LD	B,(IX+19)
	EXX
; 1510.	                        dir = dj->dir;
	LD	C,32
	EXX
	PUSH	BC
	EXX
	POP	DE
	LD	L,B
	CALL	?MEMSET_L11
; 1511.	                        memset(dir, 0, SZ_DIR); /* Clean the entry */
	LD	BC,11
	LD	L,(IX+20)
	LD	H,(IX+21)
	LDIR
; 1512.	                        memcpy(dir, dj->fn, 11);        /* Put SFN */
; 1513.	#if _USE_LFN
; 1515.	#endif
	LD	L,(IX+0)
	LD	H,(IX+1)
	LD	C,5
	ADD	HL,BC
	LD	(HL),1
?0236:
?0234:
; 1516.	                        dj->fs->wflag = 1;
; 1517.	                }
; 1518.	        }
; 1519.	
	LD	A,IYL
; 1520.	        return res;
	POP	HL
	JP	?1034
; 1521.	}
; 1522.	#endif /* !_FS_READONLY */
; 1523.	
; 1524.	
; 1525.	
; 1526.	
; 1527.	/*-----------------------------------------------------------------------*/
; 1528.	/* Remove an object from the directory                                   */
; 1529.	/*-----------------------------------------------------------------------*/
; 1530.	#if !_FS_READONLY && !_FS_MINIMIZE
; 1531.	static
; 1532.	FRESULT dir_remove (    /* FR_OK: Successful, FR_DISK_ERR: A disk error */
; 1533.	        DIR *dj                         /* Directory object pointing the entry to be removed */
; 1534.	)
dir_remove:
	PUSH	BC
	PUSH	IY
	PUSH	IX
	PUSH	DE
	POP	IX
; 1535.	{
; 1536.	        FRESULT res;
; 1537.	#if _USE_LFN    /* LFN configuration */
; 1554.	#else                   /* Non LFN configuration */
	LD	HL,4
	ADD	HL,DE
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	CALL	dir_sdi
; 1555.	        res = dir_sdi(dj, dj->index);
	OR	A
	JR	NZ,?0242
?0239:
; 1556.	        if (res == FR_OK) {
	LD	L,(IX+16)
	LD	H,(IX+17)
	PUSH	HL
	LD	L,(IX+14)
	LD	H,(IX+15)
	PUSH	HL
	CALL	?1045
	POP	HL
	POP	HL
; 1557.	                res = move_window(dj->fs, dj->sect);
	OR	A
	JR	NZ,?0242
?0241:
; 1558.	                if (res == FR_OK) {
	LD	L,(IX+18)
	LD	H,(IX+19)
	LD	(HL),229
; 1559.	                        *dj->dir = DDE;                 /* Mark the entry "deleted" */
	LD	L,(IX+0)
	LD	H,(IX+1)
	LD	BC,5
	ADD	HL,BC
	LD	(HL),1
?0242:
?0240:
; 1560.	                        dj->fs->wflag = 1;
; 1561.	                }
; 1562.	        }
; 1563.	#endif
; 1564.	
; 1565.	        return res;
	POP	IX
	POP	IY
	POP	BC
	RET
; 1566.	}
; 1567.	#endif /* !_FS_READONLY */
; 1568.	
; 1569.	
; 1570.	
; 1571.	
; 1572.	/*-----------------------------------------------------------------------*/
; 1573.	/* Pick a segment and create the object name in directory form           */
; 1574.	/*-----------------------------------------------------------------------*/
; 1575.	
; 1576.	static
; 1577.	FRESULT create_name (
; 1578.	        DIR *dj,                        /* Pointer to the directory object */
; 1579.	        const TCHAR **path      /* Pointer to pointer to the segment in the path string */
; 1580.	)
create_name:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	-6
	PUSH	IY
	EXX
	PUSH	BC
	PUSH	DE
	EXX
; 1581.	{
; 1582.	#ifdef _EXCVT
; 1584.	#endif
; 1585.	
; 1586.	#if _USE_LFN    /* LFN configuration */
; 1601.	#if !_LFN_UNICODE
; 1611.	#endif
; 1618.	#if _FS_RPATH
; 1627.	#endif
; 1662.	#ifdef _EXCVT
; 1665.	#else
; 1667.	#endif
; 1707.	#else   /* Non-LFN configuration */
; 1708.	        BYTE b, c, d, *sfn;
; 1709.	        UINT ni, si, i;
; 1710.	        const char *p;
; 1711.	
; 1712.	        /* Create file name in directory form */
	LD	A,(BC)
	LD	(IX-4),A
	INC	BC
	LD	A,(BC)
	LD	(IX-3),A
?0244:
	LD	L,(IX-4)
	LD	H,(IX-3)
	LD	A,(HL)
	CP	47
	JR	Z,?0246
	LD	A,(HL)
	CP	92
	JR	NZ,?0243
?0246:
?0247:
?0245:
	INC	(IX-4)
	JR	NZ,?0244
	INC	(IX-3)
; 1713.	        for (p = *path; *p == '/' || *p == '\\'; p++) ; /* Strip duplicated separator */
	JR	?0244
?0243:
	LD	HL,20
	LD	C,(IX+2)
	LD	B,(IX+3)
	ADD	HL,BC
	LD	B,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,B
	EX	DE,HL
; 1714.	        sfn = dj->fn;
	LD	BC,11
	LD	HL,32
	CALL	?MEMSET_L11
; 1715.	        memset(sfn, ' ', 11);
; 1716.	        si = i = b = 0; ni = 8;
; 1717.	#if _FS_RPATH
	LD	(IX-6),H
	EXX
	LD	DE,0
	LD	BC,0
	EXX
	LD	(IX-2),8
	LD	(IX-1),H
	LD	L,(IX-4)
	LD	H,(IX-3)
	LD	A,(HL)
	CP	46
	JR	NZ,?0250
?0249:
?0252:
; 1718.	        if (p[si] == '.') { /* Is this a dot entry? */
; 1719.	                for (;;) {
	EXX
	PUSH	BC
	INC	BC
	EXX
	POP	HL
	LD	C,(IX-4)
	LD	B,(IX-3)
	ADD	HL,BC
	LD	B,(HL)
	LD	IYL,B
; 1720.	                        c = (BYTE)p[si++];
	LD	A,B
	CP	46
	JR	NZ,?0251
	LD	BC,3
	EXX
	PUSH	BC
	EXX
	POP	HL
	AND	A
	SBC	HL,BC
	JR	NC,?0251
?0255:
?0256:
?0253:
?0254:
; 1721.	                        if (c != '.' || si >= 3) break;
	EXX
	PUSH	DE
	INC	DE
	EXX
	POP	HL
	ADD	HL,DE
	LD	B,IYL
	LD	(HL),B
; 1722.	                        sfn[i++] = c;
; 1723.	                }
	JR	?0249
?0251:
	CP	47
	JR	Z,?0258
	CP	92
	JR	Z,?0258
	LD	A,32
	CP	IYL
	JR	C,?0276
?0260:
?0259:
?0257:
; 1724.	                if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
?0258:
	EXX
	PUSH	BC
	EXX
	POP	HL
	LD	C,(IX-4)
	LD	B,(IX-3)
	ADD	HL,BC
	PUSH	HL
	LD	L,(IX+4)
	LD	H,(IX+5)
	POP	BC
	LD	(HL),C
	INC	HL
	LD	(HL),B
; 1725.	                *path = &p[si];                                                                 /* Return pointer to the next segment */
	LD	HL,11
	ADD	HL,DE
	LD	A,32
	CP	IYL
	JR	C,?0262
	LD	A,36
?0262:
	LD	(HL),A
; 1726.	                sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;       /* Set last segment flag if end of path */
	JP	?0949
; 1727.	                return FR_OK;
?0250:
?0265:
; 1728.	        }
; 1729.	#endif
; 1730.	        for (;;) {
	EXX
	PUSH	BC
	INC	BC
	EXX
	POP	HL
	LD	C,(IX-4)
	LD	B,(IX-3)
	ADD	HL,BC
	LD	B,(HL)
	LD	IYL,B
; 1731.	                c = (BYTE)p[si++];
	LD	A,32
	CP	B
	JR	NC,?0268
	LD	A,IYL
	CP	47
	JR	Z,?0268
	CP	92
	JR	NZ,?0267
?0268:
?0269:
?0266:
	JP	?0264
?0267:
; 1732.	                if (c <= ' ' || c == '/' || c == '\\') break;   /* Break on end of segment */
	CP	46
	JR	Z,?0272
	LD	C,(IX-2)
	LD	B,(IX-1)
	EXX
	PUSH	DE
	EXX
	POP	HL
	AND	A
	SBC	HL,BC
	JR	C,?0271
?0272:
?0273:
?0270:
; 1733.	                if (c == '.' || i >= ni) {
	LD	A,8
	XOR	(IX-2)
	OR	(IX-1)
	JR	NZ,?0953
	LD	A,IYL
	CP	46
	JR	Z,?0275
?0276:
?0277:
?0274:
	JR	?0953
; 1734.	                        if (ni != 8 || c != '.') return FR_INVALID_NAME;
?0275:
; 1735.	                        i = 8; ni = 11;
	SLA	(IX-6)
	SLA	(IX-6)
	EXX
	LD	DE,8
	EXX
	LD	(IX-2),11
	LD	(IX-1),0
	JR	?0250
?0271:
; 1736.	                        b <<= 2; continue;
; 1737.	                }
	CP	128
	JR	NC,?0954
?0278:
; 1738.	                if (c >= 0x80) {                                /* Extended char? */
; 1739.	                        b |= 3;                                         /* Eliminate NT flag */
; 1740.	#ifdef _EXCVT
; 1742.	#else
; 1743.	#if !_DF1S      /* ASCII only cfg */
; 1744.	                        return FR_INVALID_NAME;
; 1745.	#endif
; 1746.	#endif
?0279:
; 1747.	                }
	XOR	A
	JR	Z,?0281
?0280:
; 1748.	                if (IsDBCS1(c)) {                               /* Check if it is a DBC 1st byte (always false on SBCS cfg) */
	EXX
	PUSH	BC
	EXX
	POP	HL
; 1749.	                        d = (BYTE)p[si++];                      /* Get 2nd byte */
	JR	?0954
?0284:
?0285:
?0282:
; 1750.	                        if (!IsDBCS2(d) || i >= ni - 1) /* Reject invalid DBC */
; 1751.	                                return FR_INVALID_NAME;
?0283:
; 1752.	                        sfn[i++] = c;
; 1753.	                        sfn[i++] = d;
?0281:
; 1754.	                } else {                                                /* Single byte code */
	PUSH	DE
	LD	C,IYL
	LD	E,C
	LD	HL,?0289
	CALL	?STRCHR_L11
	LD	A,L
	OR	H
	POP	DE
	JR	Z,?0288
?0287:
; 1755.	                        if (strchr("\"*+,:;<=>\?[]|\x7F", c))   /* Reject illegal chrs for SFN */
?0953:
	JR	?0954
; 1756.	                                return FR_INVALID_NAME;
?0288:
	LD	A,IYL
	CP	65
	JR	C,?0291
	LD	A,90
	CP	C
	JR	C,?0291
?0293:
?0292:
?0290:
; 1757.	                        if (IsUpper(c)) {                       /* ASCII large capital? */
	SET	1,(IX-6)
; 1758.	                                b |= 2;
	JR	?0296
?0291:
; 1759.	                        } else {
	LD	A,IYL
	CP	97
	JR	C,?0296
	LD	A,122
	CP	C
	JR	C,?0296
?0298:
?0297:
?0295:
; 1760.	                                if (IsLower(c)) {               /* ASCII small capital? */
	SET	0,(IX-6)
	LD	A,IYL
	SUB	32
	LD	IYL,A
?0296:
?0294:
; 1761.	                                        b |= 1; c -= 0x20;
; 1762.	                                }
; 1763.	                        }
	EXX
	PUSH	DE
	INC	DE
	EXX
	POP	HL
	ADD	HL,DE
	LD	B,IYL
	LD	(HL),B
?0286:
; 1764.	                        sfn[i++] = c;
; 1765.	                }
; 1766.	        }
	JP	?0250
?0264:
	EXX
	PUSH	BC
	EXX
	POP	HL
	LD	B,(IX-3)
	ADD	HL,BC
	PUSH	HL
	LD	L,(IX+4)
	LD	H,(IX+5)
	POP	BC
	LD	(HL),C
	INC	HL
	LD	(HL),B
; 1767.	        *path = &p[si];                                         /* Return pointer to the next segment */
	LD	A,32
	CP	IYL
	JR	C,?0300
	LD	A,4
	JR	?0301
?0300:
	XOR	A
?0301:
	LD	IYL,A
; 1768.	        c = (c <= ' ') ? NS_LAST : 0;           /* Set last segment flag if end of path */
; 1769.	
	EXX
	LD	A,E
	OR	D
	EXX
	JR	NZ,?0303
?0302:
?0954:
	LD	A,6
; 1770.	        if (!i) return FR_INVALID_NAME;         /* Reject nul string */
	JR	?0312
?0303:
	LD	L,E
	LD	H,D
	LD	A,(HL)
	CP	229
	JR	NZ,?0305
?0304:
	LD	(HL),5
?0305:
; 1771.	        if (sfn[0] == DDE) sfn[0] = NDDE;       /* When first char collides with DDE, replace it with 0x05 */
; 1772.	
	LD	A,8
	XOR	(IX-2)
	OR	(IX-1)
	JR	NZ,?0307
?0306:
	SLA	(IX-6)
	SLA	(IX-6)
?0307:
; 1773.	        if (ni == 8) b <<= 2;
	LD	A,(IX-6)
	AND	3
	DEC	A
	JR	NZ,?0309
?0308:
	LD	A,IYL
	OR	16
	LD	IYL,A
?0309:
; 1774.	        if ((b & 0x03) == 0x01) c |= NS_EXT;    /* NT flag (Name extension has only small capital) */
	LD	A,(IX-6)
	AND	12
	CP	4
	JR	NZ,?0311
?0310:
	LD	A,IYL
	OR	8
	LD	IYL,A
?0311:
; 1775.	        if ((b & 0x0C) == 0x04) c |= NS_BODY;   /* NT flag (Name body has only small capital) */
; 1776.	
	LD	HL,11
	ADD	HL,DE
	LD	B,IYL
	LD	(HL),B
; 1777.	        sfn[NS] = c;            /* Store NT flag, File name is created */
; 1778.	
?0949:
	XOR	A
; 1779.	        return FR_OK;
; 1780.	#endif
?0312:
	JP	?0154
; 1781.	}
; 1782.	
; 1783.	
; 1784.	
; 1785.	
; 1786.	/*-----------------------------------------------------------------------*/
; 1787.	/* Get file information from directory entry                             */
; 1788.	/*-----------------------------------------------------------------------*/
; 1789.	#if _FS_MINIMIZE <= 1
; 1790.	static
; 1791.	void get_fileinfo (             /* No return code */
; 1792.	        DIR *dj,                        /* Pointer to the directory object */
; 1793.	        FILINFO *fno            /* Pointer to the file information to be filled */
; 1794.	)
get_fileinfo:
	PUSH	IY
	PUSH	IX
	EXX
	PUSH	BC
	PUSH	DE
	EXX
	PUSH	DE
	PUSH	AF
	PUSH	BC
	POP	IY
; 1795.	{
; 1796.	        UINT i;
; 1797.	        BYTE nt, *dir;
; 1798.	        TCHAR *p, c;
; 1799.	
; 1800.	
	LD	HL,9
	ADD	HL,BC
	PUSH	HL
	EXX
	POP	BC
	EXX
; 1801.	        p = fno->fname;
	LD	L,E
	LD	H,D
	LD	BC,14
	ADD	HL,BC
	LD	A,(HL)
	INC	HL
	OR	(HL)
	INC	HL
	OR	(HL)
	INC	HL
	OR	(HL)
	JP	Z,?0314
?0313:
; 1802.	        if (dj->sect) {
	LD	C,E
	LD	B,D
	LD	HL,18
	ADD	HL,BC
	LD	B,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,B
	PUSH	HL
	POP	IX
; 1803.	                dir = dj->dir;
	LD	BC,12
	ADD	HL,BC
	LD	B,(HL)
	LD	HL,1
	ADD	HL,SP
	LD	(HL),B
; 1804.	                nt = dir[DIR_NTres];            /* NT flag */
	EXX
	LD	DE,0
?0959:
	EXX
?0316:
	LD	BC,8
	EXX
	PUSH	DE
	EXX
	POP	HL
	AND	A
	SBC	HL,BC
	JR	NC,?0315
?0317:
; 1805.	                for (i = 0; i < 8; i++) {       /* Copy name body */
	EXX
	PUSH	DE
	EXX
	POP	HL
	PUSH	IX
	POP	BC
	ADD	HL,BC
	LD	B,(HL)
	LD	HL,0
	ADD	HL,SP
	LD	(HL),B
; 1806.	                        c = dir[i];
	LD	A,B
	CP	32
	JR	Z,?0315
?0319:
?0320:
; 1807.	                        if (c == ' ') break;
	CP	5
	JR	NZ,?0322
?0321:
	LD	(HL),229
?0322:
; 1808.	                        if (c == NDDE) c = (TCHAR)DDE;
	XOR	A
	JR	Z,?0324
	INC	HL
	BIT	3,(HL)
	JR	Z,?0324
	DEC	HL
	LD	A,(HL)
	XOR	128
	CP	193
	JR	C,?0324
	LD	A,90
	SUB	(HL)
	JP	PO,?0957
	XOR	128
?0957:
	JP	M,?0324
?0328:
?0327:
?0326:
?0325:
?0323:
	LD	A,(HL)
	ADD	A,32
	LD	(HL),A
?0324:
; 1809.	                        if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
; 1810.	#if _LFN_UNICODE
; 1815.	#endif
	EXX
	PUSH	BC
	INC	BC
	EXX
	LD	HL,2
	ADD	HL,SP
	LD	B,(HL)
	POP	HL
	LD	(HL),B
	EXX
	INC	DE
	JR	?0959
; 1816.	                        *p++ = c;
; 1817.	                }
?0315:
	LD	A,(IX+8)
	CP	32
	JR	Z,?0331
?0329:
; 1818.	                if (dir[8] != ' ') {            /* Copy name extension */
	EXX
	PUSH	BC
	INC	BC
	EXX
	POP	HL
	LD	(HL),46
; 1819.	                        *p++ = '.';
	EXX
	LD	DE,8
?0960:
	EXX
?0332:
	LD	BC,11
	EXX
	PUSH	DE
	EXX
	POP	HL
	AND	A
	SBC	HL,BC
	JR	NC,?0331
?0333:
; 1820.	                        for (i = 8; i < 11; i++) {
	EXX
	PUSH	DE
	EXX
	POP	HL
	PUSH	IX
	POP	BC
	ADD	HL,BC
	LD	B,(HL)
	LD	HL,0
	ADD	HL,SP
	LD	(HL),B
; 1821.	                                c = dir[i];
	LD	A,B
	CP	32
	JR	Z,?0331
?0335:
?0336:
; 1822.	                                if (c == ' ') break;
	XOR	A
	JR	Z,?0338
	INC	HL
	BIT	4,(HL)
	JR	Z,?0338
	LD	A,B
	XOR	128
	CP	193
	JR	C,?0338
	LD	A,90
	SUB	B
	JP	PO,?0958
	XOR	128
?0958:
	JP	M,?0338
?0342:
?0341:
?0340:
?0339:
?0337:
	DEC	HL
	LD	A,B
	ADD	A,32
	LD	(HL),A
?0338:
; 1823.	                                if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
; 1824.	#if _LFN_UNICODE
; 1829.	#endif
	EXX
	PUSH	BC
	INC	BC
	EXX
	LD	HL,2
	ADD	HL,SP
	LD	B,(HL)
	POP	HL
	LD	(HL),B
	EXX
	INC	DE
	JR	?0960
; 1830.	                                *p++ = c;
; 1831.	                        }
?0331:
?0330:
; 1832.	                }
	LD	B,(IX+11)
	LD	(IY+8),B
; 1833.	                fno->fattrib = dir[DIR_Attr];                           /* Attribute */
	LD	C,(IX+30)
	LD	B,(IX+31)
	LD	L,(IX+28)
	LD	H,(IX+29)
	PUSH	HL
	PUSH	IY
	POP	DE
	EX	DE,HL
	POP	DE
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	LD	(HL),C
	INC	HL
	LD	(HL),B
; 1834.	                fno->fsize = LD_DWORD(dir+DIR_FileSize);        /* Size */
	LD	L,(IX+24)
	LD	(IY+4),L
	LD	H,(IX+25)
	LD	(IY+5),H
; 1835.	                fno->fdate = LD_WORD(dir+DIR_WrtDate);          /* Date */
	LD	L,(IX+22)
	LD	(IY+6),L
	LD	H,(IX+23)
	LD	(IY+7),H
?0314:
; 1836.	                fno->ftime = LD_WORD(dir+DIR_WrtTime);          /* Time */
; 1837.	        }
	EXX
	PUSH	BC
	EXX
	POP	HL
	LD	(HL),0
; 1838.	        *p = 0;         /* Terminate SFN str by a \0 */
; 1839.	
; 1840.	#if _USE_LFN
; 1849.	#if !_LFN_UNICODE
; 1854.	#endif
; 1861.	#endif
	POP	HL
	POP	HL
	EXX
	POP	DE
	POP	BC
	EXX
	POP	IX
	POP	IY
	RET
; 1862.	}
; 1863.	#endif /* _FS_MINIMIZE <= 1 */
; 1864.	
; 1865.	
; 1866.	
; 1867.	
; 1868.	/*-----------------------------------------------------------------------*/
; 1869.	/* Follow a file path                                                    */
; 1870.	/*-----------------------------------------------------------------------*/
; 1871.	
; 1872.	static
; 1873.	FRESULT follow_path (   /* FR_OK(0): successful, !=0: error code */
; 1874.	        DIR *dj,                        /* Directory object to return last directory and found object */
; 1875.	        const TCHAR *path       /* Full-path string to find a file or directory */
; 1876.	)
follow_path:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	-2
	PUSH	IY
	EXX
	PUSH	BC
	EXX
	LD	L,(IX+2)
	LD	H,(IX+3)
	PUSH	HL
	POP	IY
; 1877.	{
; 1878.	        FRESULT res;
; 1879.	        BYTE *dir, ns;
; 1880.	
; 1881.	
; 1882.	#if _FS_RPATH
	LD	A,(BC)
	CP	47
	JR	Z,?0345
	LD	L,C
	LD	H,B
	LD	A,(HL)
	CP	92
	JR	NZ,?0344
?0345:
?0346:
?0343:
; 1883.	        if (*path == '/' || *path == '\\') { /* There is a heading separator */
	INC	(IX+4)
	JR	NZ,?0962
	INC	(IX+5)
?0962:
	XOR	A
	LD	(IY+6),A
	LD	(IY+7),A
	LD	(IY+8),A
	LD	(IY+9),A
; 1884.	                path++; dj->sclust = 0;         /* Strip it and start from the root dir */
	JR	?0347
?0344:
; 1885.	        } else {                                                        /* No heading separator */
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	BC,23
	ADD	HL,BC
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	EX	DE,HL
	LD	(IY+6),L
	LD	(IY+7),H
	LD	(IY+8),C
	LD	(IY+9),B
?0347:
; 1886.	                dj->sclust = dj->fs->cdir;      /* Start from the current dir */
; 1887.	        }
; 1888.	#else
; 1892.	#endif
; 1893.	
	LD	L,(IX+4)
	LD	H,(IX+5)
	LD	A,(HL)
	CP	32
	JR	NC,?0349
?0348:
; 1894.	        if ((UINT)*path < ' ') {                        /* Nul path means the start directory itself */
	LD	BC,0
	PUSH	IY
	POP	DE
	CALL	dir_sdi
	LD	(IX-2),A
; 1895.	                res = dir_sdi(dj, 0);
	XOR	A
	LD	(IY+18),A
	LD	(IY+19),A
; 1896.	                dj->dir = 0;
; 1897.	
	JP	?0351
?0349:
?0352:
; 1898.	        } else {                                                        /* Follow path */
; 1899.	                for (;;) {
	LD	HL,10
	ADD	HL,SP
	LD	C,L
	LD	B,H
	PUSH	IY
	POP	DE
	CALL	create_name
	LD	(IX-2),A
; 1900.	                        res = create_name(dj, &path);   /* Get a segment */
	OR	A
	JR	NZ,?0351
?0353:
?0354:
; 1901.	                        if (res != FR_OK) break;
	PUSH	IY
	POP	DE
	CALL	dir_find
	LD	(IX-2),A
; 1902.	                        res = dir_find(dj);                             /* Find it */
	LD	L,(IY+20)
	LD	H,(IY+21)
	LD	BC,11
	ADD	HL,BC
	LD	B,(HL)
; 1903.	                        ns = *(dj->fn+NS);
	OR	A
	JR	Z,?0356
?0355:
; 1904.	                        if (res != FR_OK) {                             /* Failed to find the object */
	CP	4
	JR	NZ,?0351
?0357:
?0358:
; 1905.	                                if (res != FR_NO_FILE) break;   /* Abort if any hard error occured */
; 1906.	                                /* Object not found */
	BIT	5,B
	JR	Z,?0360
?0362:
?0361:
?0359:
; 1907.	                                if (_FS_RPATH && (ns & NS_DOT)) {       /* If dot entry is not exit */
	XOR	A
	LD	(IY+6),A
	LD	(IY+7),A
	LD	(IY+8),A
	LD	(IY+9),A
	LD	(IY+18),A
	LD	(IY+19),A
; 1908.	                                        dj->sclust = 0; dj->dir = 0;    /* It is the root dir */
	LD	(IX-2),A
; 1909.	                                        res = FR_OK;
	BIT	2,B
	JR	NZ,?0351
?0363:
	JR	?0349
?0364:
; 1910.	                                        if (!(ns & NS_LAST)) continue;
?0360:
; 1911.	                                } else {                                                        /* Could not find the object */
	BIT	2,B
	JR	NZ,?0351
?0366:
	JR	?0964
?0367:
?0365:
; 1912.	                                        if (!(ns & NS_LAST)) res = FR_NO_PATH;
; 1913.	                                }
?0356:
; 1914.	                                break;
; 1915.	                        }
	BIT	2,B
	JR	NZ,?0351
?0368:
?0369:
; 1916.	                        if (ns & NS_LAST) break;                        /* Last segment match. Function completed. */
	EXX
	LD	C,(IY+18)
	LD	B,(IY+19)
	EXX
; 1917.	                        dir = dj->dir;                                          /* There is next segment. Follow the sub directory */
	LD	L,C
	LD	H,A
	EXX
	PUSH	BC
	EXX
	POP	BC
	ADD	HL,BC
	BIT	4,(HL)
	JR	NZ,?0371
?0370:
; 1918.	                        if (!(dir[DIR_Attr] & AM_DIR)) {        /* Cannot follow because it is a file */
?0964:
	LD	(IX-2),5
	JR	?0351
?0371:
; 1919.	                                res = FR_NO_PATH; break;
; 1920.	                        }
	EXX
	PUSH	BC
	EXX
	POP	DE
	CALL	LD_CLUST
	LD	(IY+6),L
	LD	(IY+7),H
	LD	(IY+8),C
	LD	(IY+9),B
; 1921.	                        dj->sclust = LD_CLUST(dir);
; 1922.	                }
	JP	?0349
?0351:
?0350:
; 1923.	        }
; 1924.	
	LD	A,(IX-2)
; 1925.	        return res;
	JP	?0190
; 1926.	}
; 1927.	
; 1928.	
; 1929.	
; 1930.	
; 1931.	/*-----------------------------------------------------------------------*/
; 1932.	/* Load boot record and check if it is an FAT boot record                */
; 1933.	/*-----------------------------------------------------------------------*/
; 1934.	
; 1935.	static
; 1936.	BYTE check_fs ( /* 0:The FAT BR, 1:Valid BR but not an FAT, 2:Not a BR, 3:Disk error */
; 1937.	        FATFS *fs,      /* File system object */
; 1938.	        DWORD sect      /* Sector# (lba) to check if it is an FAT boot record or not */
; 1939.	)
check_fs:
	PUSH	BC
	PUSH	IX
	PUSH	DE
	POP	IX
	EX	DE,HL
	INC	HL
	LD	A,(HL)
	LD	(dio_par),A
	LD	HL,51
	PUSH	IX
	POP	BC
	ADD	HL,BC
	LD	(dio_par+1),HL
	LD	HL,6
	ADD	HL,SP
; 1940.	{       SET_DIO_PAR(fs->drv, fs->win, sect,1);
	CALL	?1041
	JR	Z,?0373
?0372:
; 1941.	        if (disk_read() != RES_OK)      /* Load boot record */
	LD	A,3
; 1942.	                return 3;
	JR	?0380
?0373:
	LD	HL,561
	PUSH	IX
	POP	BC
	ADD	HL,BC
	LD	B,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,B
	LD	BC,43605
	AND	A
	SBC	HL,BC
	JR	Z,?0375
?0374:
; 1943.	        if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)               /* Check record signature (always placed at offset 510 even if the sector size is >512) */
	LD	A,2
; 1944.	                return 2;
; 1945.	
	JR	?0380
?0375:
	LD	E,(IX+107)
	LD	L,(IX+105)
	LD	H,(IX+106)
	LD	D,A
	LD	BC,16710
	AND	A
	SBC	HL,BC
	JR	NZ,?0377
	EX	DE,HL
	LD	BC,84
	SBC	HL,BC
	JR	Z,?0380
?0376:
; 1946.	        if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146) /* Check "FAT" string */
; 1947.	                return 0;
?0377:
	LD	HL,133
	PUSH	IX
	POP	BC
	ADD	HL,BC
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	INC	HL
	LD	E,(HL)
	LD	L,C
	LD	H,B
	LD	D,A
	LD	BC,16710
	AND	A
	SBC	HL,BC
	JR	NZ,?0379
	EX	DE,HL
	LD	BC,84
	SBC	HL,BC
	JR	Z,?0380
?0378:
; 1948.	        if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
; 1949.	                return 0;
; 1950.	
?0379:
	LD	A,1
; 1951.	        return 1;
?0380:
	POP	IX
	POP	BC
	RET
; 1952.	}
; 1953.	
; 1954.	
; 1955.	
; 1956.	
; 1957.	/*-----------------------------------------------------------------------*/
; 1958.	/* Check if the file system object is valid or not                       */
; 1959.	/*-----------------------------------------------------------------------*/
; 1960.	
; 1961.	static
; 1962.	FRESULT chk_mounted (   /* FR_OK(0): successful, !=0: any error occurred */
; 1963.	        const TCHAR **path,     /* Pointer to pointer to the path name (drive number) */
; 1964.	        FATFS **rfs,            /* Pointer to pointer to the found file system object */
; 1965.	        BYTE chk_wp                     /* !=0: Check media write protection for write access */
; 1966.	)
chk_mounted:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	-32
	PUSH	IY
	EXX
	PUSH	BC
	PUSH	DE
	EXX
; 1967.	{
; 1968.	        BYTE fmt, b, *tbl;
; 1969.	        UINT vol;
; 1970.	        DSTATUS stat;
; 1971.	        DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
; 1972.	        WORD nrsv;
	LD	L,(IX+2)
	LD	H,(IX+3)
	LD	D,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,D
	LD	(IX-26),L
	LD	(IX-25),H
; 1973.	        const TCHAR *p = *path;
; 1974.	        FATFS *fs;
; 1975.	
; 1976.	        /* Get logical drive number from the path name */
	LD	E,(HL)
	LD	A,E
	RLCA
	SBC	A,A
	LD	D,A
	LD	HL,65488
	ADD	HL,DE
	PUSH	HL
	EXX
	POP	BC
	EXX
; 1977.	        vol = p[0] - '0';                                       /* Is there a drive number? */
	EX	DE,HL
	LD	HL,9
	AND	A
	SBC	HL,DE
	JR	C,?0382
	LD	L,(IX-26)
	LD	H,(IX-25)
	INC	HL
	LD	A,(HL)
	CP	58
	JR	NZ,?0382
?0384:
?0383:
?0381:
; 1978.	        if (vol <= 9 && p[1] == ':') {          /* Found a drive number, get and strip it */
	LD	HL,12
	ADD	HL,SP
	LD	A,(HL)
	ADD	A,2
	LD	(HL),A
	INC	HL
	LD	A,(HL)
	ADC	A,0
	LD	L,(IX-26)
	LD	H,A
	PUSH	HL
	LD	L,(IX+2)
	LD	H,(IX+3)
	POP	BC
	LD	(HL),C
	INC	HL
	LD	(HL),B
; 1979.	                p += 2; *path = p;                              /* Return pointer to the path name */
	JR	?0385
?0382:
; 1980.	        } else {                                                        /* No drive number is given */
; 1981.	#if _FS_RPATH
	LD	BC,(CurrVol)
	LD	B,0
	PUSH	BC
	EXX
	POP	BC
	EXX
?0385:
; 1982.	                vol = CurrVol;                                  /* Use current drive */
; 1983.	#else
; 1985.	#endif
; 1986.	        }
; 1987.	
; 1988.	        /* Check if the logical drive is valid or not */
	LD	BC,2
	EXX
	PUSH	BC
	EXX
	POP	HL
	AND	A
	SBC	HL,BC
	JR	C,?0387
?0386:
; 1989.	        if (vol >= _VOLUMES)                            /* Is the drive number valid? */
	LD	A,11
; 1990.	                return FR_INVALID_DRIVE;
	JP	?0456
?0387:
	EXX
	PUSH	BC
	EXX
	POP	HL
	ADD	HL,HL
	LD	BC,FatFs
	ADD	HL,BC
	LD	B,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,B
	PUSH	HL
	POP	IY
	PUSH	HL
	LD	L,(IX+4)
	LD	H,(IX+5)
	POP	BC
	LD	(HL),C
	INC	HL
	LD	(HL),B
; 1991.	        *rfs = fs = FatFs[vol];                         /* Return pointer to the corresponding file system object */
	LD	A,IYL
	OR	IYH
	JR	NZ,?0389
?0388:
	LD	A,12
; 1992.	        if (!fs) return FR_NOT_ENABLED;         /* Is the file system object available? */
; 1993.	
	JP	?0456
?0389:
; 1994.	        ENTER_FF(fs);                                           /* Lock file system */
; 1995.	
	XOR	A
	OR	(IY+0)
	JR	Z,?0393
?0390:
; 1996.	        if (fs->fs_type) {                                      /* If the logical drive has been mounted */
	LD	C,(IY+1)
	LD	B,0
	LD	HL,ds_m
	ADD	HL,BC
	LD	B,(HL)
; 1997.	                stat = disk_status(fs->drv);
	BIT	0,B
	JR	NZ,?0393
?0392:
; 1998.	                if (!(stat & STA_NOINIT)) {             /* and the physical drive is kept initialized (has not been changed), */
; 1999.	#if !_FS_READONLY
	XOR	A
	OR	(IX+8)
	JR	Z,?0395
	BIT	2,B
	JR	NZ,?0969
?0397:
?0396:
?0394:
; 2000.	                        if (chk_wp && (stat & STA_PROTECT))     /* Check write protection if needed */
; 2001.	                                return FR_WRITE_PROTECTED;
; 2002.	#endif
?0395:
	JP	?0968
; 2003.	                        return FR_OK;                           /* The file system object is valid */
?0393:
?0391:
; 2004.	                }
; 2005.	        }
; 2006.	
; 2007.	        /* The logical drive must be mounted. */
; 2008.	        /* Following code attempts to mount a volume. (analyze BPB and initialize the fs object) */
; 2009.	
	LD	(IY+0),0
; 2010.	        fs->fs_type = 0;                                        /* Clear the file system object */
; 2011.	        //Dimkam fs->drv = (BYTE)LD2PD(vol);                    /* Bind the logical drive and a physical drive */
	LD	HL,51
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	C,L
	LD	B,H
	LD	E,(IY+1)
	CALL	disk_initialize
	LD	(IX-2),A
; 2012.	        stat = disk_initialize(fs->drv,fs->win);        /* Initialize low level disk I/O layer */
	BIT	0,A
	JR	Z,?0399
?0398:
; 2013.	        if (stat & STA_NOINIT)                          /* Check if the initialization succeeded */
	LD	A,3
; 2014.	                return FR_NOT_READY;                    /* Failed to initialize due to no media or hard error */
; 2015.	#if _MAX_SS != 512                                              /* Get disk sector size (variable sector size cfg only) */
; 2018.	#endif
; 2019.	#if !_FS_READONLY
	JP	?0456
?0399:
	XOR	A
	OR	(IX+8)
	JR	Z,?0401
	BIT	2,(IX-2)
	JR	Z,?0401
?0403:
?0402:
?0400:
; 2020.	        if (chk_wp && (stat & STA_PROTECT))     /* Check disk write protection if needed */
?0969:
	LD	A,10
; 2021.	                return FR_WRITE_PROTECTED;
; 2022.	#endif
; 2023.	        /* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	JP	?0456
?0401:
	XOR	A
	LD	(IX-24),A
	LD	(IX-23),A
	LD	(IX-22),A
	LD	(IX-21),A
	LD	L,A
	LD	H,A
	PUSH	HL
	PUSH	HL
	PUSH	IY
	POP	DE
	CALL	check_fs
	POP	HL
	POP	HL
	LD	(IX-32),A
; 2024.	        fmt = check_fs(fs, bsect = 0);          /* Check sector 0 if it is a VBR */
	DEC	A
	JR	NZ,?0407
?0404:
; 2025.	        if (fmt == 1) {                                         /* Not an FAT-VBR, the disk may be partitioned */
; 2026.	                /* Check the partition listed in top of the partition table */
; 2027.	                //DimkaM tbl = &fs->win[MBR_Table + LD2PT(vol) * SZ_PTE];/* Partition table */
	LD	L,(IY+2)
	LD	H,A
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	BC,497
	ADD	HL,BC
	PUSH	HL
	EXX
	POP	DE
	EXX
; 2028.	                tbl = &fs->win[MBR_Table + fs->part * SZ_PTE];/* Partition table */
	LD	BC,4
	ADD	HL,BC
	LD	A,(HL)
	OR	A
	JR	Z,?0407
?0406:
; 2029.	                if (tbl[4]) {                                                                   /* Is the partition existing? */
	LD	HL,8
	EXX
	PUSH	DE
	EXX
	POP	BC
	ADD	HL,BC
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	EX	DE,HL
	LD	(IX-24),L
	LD	(IX-23),H
	LD	(IX-22),C
	LD	(IX-21),B
; 2030.	                        bsect = LD_DWORD(&tbl[8]);                                      /* Partition offset in LBA */
	PUSH	BC
	PUSH	HL
	PUSH	IY
	POP	DE
	CALL	check_fs
	POP	HL
	POP	HL
	LD	(IX-32),A
?0407:
?0405:
; 2031.	                        fmt = check_fs(fs, bsect);                                      /* Check the partition */
; 2032.	                }
; 2033.	        }
	LD	A,(IX-32)
	CP	3
	JR	NZ,?0409
?0408:
	LD	A,1
; 2034.	        if (fmt == 3) return FR_DISK_ERR;
	JP	?0456
?0409:
	XOR	A
	OR	(IX-32)
	JR	NZ,?0971
?0410:
; 2035.	        if (fmt) return FR_NO_FILESYSTEM;                                       /* No FAT volume is found */
; 2036.	
; 2037.	        /* Following code initializes the file system object */
; 2038.	
?0411:
	LD	HL,51
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	BC,11
	ADD	HL,BC
	LD	A,2
	INC	HL
	XOR	(HL)
	DEC	HL
	OR	(HL)
	JR	NZ,?0971
?0412:
; 2039.	        if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))          /* (BPB_BytsPerSec must be equal to the physical sector size) */
; 2040.	                return FR_NO_FILESYSTEM;
; 2041.	
?0413:
	LD	HL,51
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	BC,22
	ADD	HL,BC
	LD	B,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,B
	LD	(IX-30),L
	LD	C,A
	LD	B,A
	LD	(IX-29),H
	LD	(IX-28),C
	LD	(IX-27),B
; 2042.	        fasize = LD_WORD(fs->win+BPB_FATSz16);                          /* Number of sectors per FAT */
	LD	A,L
	OR	H
	JR	NZ,?0415
?0414:
	LD	HL,51
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	BC,36
	ADD	HL,BC
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	EX	DE,HL
	LD	(IX-30),L
	LD	(IX-29),H
	LD	(IX-28),C
	LD	(IX-27),B
?0415:
; 2043.	        if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	LD	(IY+31),L
	LD	(IY+32),H
	LD	(IY+33),C
	LD	(IY+34),B
; 2044.	        fs->fsize = fasize;
; 2045.	
	LD	B,(IY+67)
	LD	(IX-31),B
	LD	(IY+4),B
; 2046.	        fs->n_fats = b = fs->win[BPB_NumFATs];                          /* Number of FAT copies */
	DEC	B
	JR	Z,?0417
	LD	B,(IX-31)
	DEC	B
	DEC	B
	JR	Z,?0417
?0419:
?0418:
?0416:
?0971:
	JR	?0973
; 2047.	        if (b != 1 && b != 2) return FR_NO_FILESYSTEM;          /* (Must be 1 or 2) */
?0417:
	LD	HL,8
	ADD	HL,SP
	LD	E,(IX-31)
	LD	C,B
	LD	D,C
	CALL	?L_MULASG_L03
; 2048.	        fasize *= b;                                                                            /* Number of sectors for FAT area */
; 2049.	
	LD	B,(IY+64)
	LD	(IY+3),B
; 2050.	        fs->csize = b = fs->win[BPB_SecPerClus];                        /* Number of sectors per cluster */
	XOR	A
	OR	B
	JR	Z,?0974
	ADD	A,255
	AND	B
	JR	NZ,?0974
?0422:
?0423:
?0420:
; 2051.	        if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;       /* (Must be power of 2) */
; 2052.	
?0421:
	LD	HL,51
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	DE,17
	ADD	HL,DE
	LD	D,(HL)
	LD	(IY+9),D
	INC	HL
	LD	H,(HL)
	LD	(IY+10),H
; 2053.	        fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);        /* Number of root directory entries */
	LD	HL,9
	ADD	HL,BC
	LD	A,(HL)
	AND	15
	JR	Z,?0425
?0424:
?0973:
	JR	?0974
; 2054.	        if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must be sector aligned) */
; 2055.	
?0425:
	LD	HL,51
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	BC,19
	ADD	HL,BC
	LD	B,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,B
	LD	(IX-16),L
	LD	C,A
	LD	B,A
	LD	(IX-15),H
	LD	(IX-14),C
	LD	(IX-13),B
; 2056.	        tsect = LD_WORD(fs->win+BPB_TotSec16);                          /* Number of sectors on the volume */
	LD	A,L
	OR	H
	JR	NZ,?0427
?0426:
	LD	HL,51
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	BC,32
	ADD	HL,BC
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	EX	DE,HL
	LD	(IX-16),L
	LD	(IX-15),H
	LD	(IX-14),C
	LD	(IX-13),B
?0427:
; 2057.	        if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
; 2058.	
	LD	HL,51
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	BC,14
	ADD	HL,BC
	LD	B,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,B
	LD	(IX-12),L
	LD	(IX-11),H
; 2059.	        nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);                         /* Number of reserved sectors */
	LD	A,L
	OR	H
	JR	NZ,?0429
?0428:
?0974:
	JR	?0975
; 2060.	        if (!nrsv) return FR_NO_FILESYSTEM;                                     /* (BPB_RsvdSecCnt must not be 0) */
; 2061.	
; 2062.	        /* Determine the FAT sub type */
?0429:
	LD	E,(IY+9)
	LD	D,(IY+10)
	LD	B,4
	CALL	?US_RSH_L02
	ADD	HL,DE
	LD	BC,0
	PUSH	BC
	PUSH	HL
	LD	L,(IX-30)
	LD	H,(IX-29)
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	LD	L,(IX-28)
	LD	H,(IX-27)
	POP	BC
	ADC	HL,BC
	LD	C,L
	LD	B,H
	EX	DE,HL
	LD	(IX-10),L
	LD	(IX-9),H
	LD	(IX-8),C
	LD	(IX-7),B
; 2063.	        sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);     /* RSV+FAT+DIR */
	PUSH	BC
	PUSH	HL
	AND	A
	LD	L,(IX-16)
	LD	H,(IX-15)
	POP	BC
	SBC	HL,BC
	LD	L,(IX-14)
	LD	H,(IX-13)
	POP	BC
	SBC	HL,BC
	JR	NC,?0431
?0430:
?0975:
	JR	?0976
; 2064.	        if (tsect < sysect) return FR_NO_FILESYSTEM;            /* (Invalid volume size) */
?0431:
	LD	L,(IY+3)
	LD	BC,0
	LD	H,C
	PUSH	BC
	PUSH	HL
	LD	L,(IX-16)
	LD	H,(IX-15)
	LD	C,(IX-10)
	LD	B,(IX-9)
	SBC	HL,BC
	EX	DE,HL
	LD	L,(IX-14)
	LD	H,(IX-13)
	LD	C,(IX-8)
	LD	B,(IX-7)
	SBC	HL,BC
	CALL	?1058
	LD	(IX-20),L
	LD	(IX-19),H
	LD	(IX-18),C
	LD	(IX-17),B
; 2065.	        nclst = (tsect - sysect) / fs->csize;                           /* Number of clusters */
	LD	A,L
	OR	H
	OR	C
	OR	B
	JR	NZ,?0433
?0432:
?0976:
	JP	?0979
; 2066.	        if (!nclst) return FR_NO_FILESYSTEM;                            /* (Invalid volume size) */
?0433:
	LD	(IX-32),1
; 2067.	        fmt = FS_FAT12;
	LD	BC,4086
	SBC	HL,BC
	LD	L,(IX-18)
	LD	H,(IX-17)
	LD	BC,0
	SBC	HL,BC
	JR	C,?0435
?0434:
	LD	(IX-32),2
?0435:
; 2068.	        if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	AND	A
	LD	L,(IX-20)
	LD	H,(IX-19)
	LD	BC,65526
	SBC	HL,BC
	LD	L,(IX-18)
	LD	H,(IX-17)
	LD	BC,0
	SBC	HL,BC
	JR	C,?0437
?0436:
	LD	(IX-32),3
?0437:
; 2069.	        if (nclst >= MIN_FAT32) fmt = FS_FAT32;
; 2070.	
; 2071.	        /* Boundaries and Limits */
	LD	L,C
	LD	H,B
	PUSH	BC
	INC	HL
	INC	HL
	PUSH	HL
	LD	L,(IX-20)
	LD	H,(IX-19)
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	LD	L,(IX-18)
	LD	H,(IX-17)
	POP	BC
	ADC	HL,BC
	LD	C,L
	LD	B,H
	EX	DE,HL
	LD	(IY+27),L
	LD	(IY+28),H
	LD	(IY+29),C
	LD	(IY+30),B
; 2072.	        fs->n_fatent = nclst + 2;                                                       /* Number of FAT entries */
	LD	L,(IX-8)
	LD	H,(IX-7)
	PUSH	HL
	LD	L,(IX-10)
	LD	H,(IX-9)
	PUSH	HL
	LD	L,(IX-24)
	LD	H,(IX-23)
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	LD	L,(IX-22)
	LD	H,(IX-21)
	POP	BC
	ADC	HL,BC
	LD	C,L
	LD	B,H
	EX	DE,HL
	LD	(IY+43),L
	LD	(IY+44),H
	LD	(IY+45),C
	LD	(IY+46),B
; 2073.	        fs->database = bsect + sysect;                                          /* Data start sector */
	LD	L,(IX-12)
	LD	H,(IX-11)
	LD	BC,0
	PUSH	BC
	PUSH	HL
	LD	L,(IX-24)
	LD	H,(IX-23)
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	LD	L,(IX-22)
	LD	H,(IX-21)
	POP	BC
	ADC	HL,BC
	LD	C,L
	LD	B,H
	EX	DE,HL
	LD	(IY+35),L
	LD	(IY+36),H
	LD	(IY+37),C
	LD	(IY+38),B
; 2074.	        fs->fatbase = bsect + nrsv;                                             /* FAT start sector */
	LD	A,(IX-32)
	CP	3
	LD	A,(IY+9)
	JR	NZ,?0439
?0438:
; 2075.	        if (fmt == FS_FAT32) {
	OR	(IY+10)
	JR	NZ,?0978
?0440:
; 2076.	                if (fs->n_rootdir) return FR_NO_FILESYSTEM;             /* (BPB_RootEntCnt must be 0) */
?0441:
	LD	HL,51
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	DE,44
	ADD	HL,DE
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	(IY+39),C
	LD	(IY+40),B
	LD	(IY+41),E
	LD	(IY+42),D
; 2077.	                fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);   /* Root directory start cluster */
	LD	C,(IY+29)
	LD	B,(IY+30)
	LD	L,(IY+27)
	LD	H,(IY+28)
	LD	A,2
	CALL	?L_LSH_L03
	JP	?0447
; 2078.	                szbfat = fs->n_fatent * 4;                                              /* (Required FAT size) */
?0439:
; 2079.	        } else {
	OR	(IY+10)
	JR	NZ,?0444
?0443:
?0978:
	JP	?0979
; 2080.	                if (!fs->n_rootdir)     return FR_NO_FILESYSTEM;        /* (BPB_RootEntCnt must not be 0) */
?0444:
	LD	L,(IY+37)
	LD	H,(IY+38)
	PUSH	HL
	LD	L,(IY+35)
	LD	H,(IY+36)
	PUSH	HL
	LD	L,(IX-30)
	LD	H,(IX-29)
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	LD	L,(IX-28)
	LD	H,(IX-27)
	POP	BC
	ADC	HL,BC
	LD	C,L
	LD	B,H
	EX	DE,HL
	LD	(IY+39),L
	LD	(IY+40),H
	LD	(IY+41),C
	LD	(IY+42),B
; 2081.	                fs->dirbase = fs->fatbase + fasize;                             /* Root directory start sector */
; 2082.	                szbfat = (fmt == FS_FAT16) ?                                    /* (Required FAT size) */
	LD	B,(IX-32)
	DEC	B
	DEC	B
	JR	NZ,?0446
	LD	C,(IY+29)
	LD	B,(IY+30)
	LD	L,(IY+27)
	LD	H,(IY+28)
	ADD	HL,HL
	RL	C
	RL	B
	JR	?0447
?0446:
	LD	L,(IY+29)
	LD	H,(IY+30)
	PUSH	HL
	LD	L,(IY+27)
	LD	H,(IY+28)
	PUSH	HL
	LD	BC,0
	LD	HL,3
	CALL	?L_MUL_L03
	LD	A,1
	CALL	?UL_RSH_L03
	PUSH	BC
	PUSH	HL
	LD	A,(IY+27)
	AND	1
	LD	L,A
	LD	H,0
	LD	E,H
	LD	D,E
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	POP	BC
	ADC	HL,BC
	LD	C,L
	LD	B,H
	EX	DE,HL
?0447:
	LD	(IX-6),L
	LD	(IX-5),H
	LD	(IX-4),C
	LD	(IX-3),B
?0442:
; 2083.	                        fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
; 2084.	        }
	LD	HL,0
	PUSH	HL
	LD	HL,511
	PUSH	HL
	LD	L,(IX-6)
	LD	H,(IX-5)
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	LD	L,(IX-4)
	LD	H,(IX-3)
	POP	BC
	ADC	HL,BC
	LD	C,L
	LD	B,H
	EX	DE,HL
	LD	A,9
	CALL	?UL_RSH_L03
	PUSH	BC
	PUSH	HL
	AND	A
	LD	L,(IY+31)
	LD	H,(IY+32)
	POP	BC
	SBC	HL,BC
	LD	L,(IY+33)
	LD	H,(IY+34)
	POP	BC
	SBC	HL,BC
	JR	NC,?0449
?0448:
; 2085.	        if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))       /* (BPB_FATSz must not be less than required) */
?0979:
	LD	A,13
; 2086.	                return FR_NO_FILESYSTEM;
; 2087.	
; 2088.	#if !_FS_READONLY
; 2089.	        /* Initialize cluster allocation information */
	JP	?0456
?0449:
	LD	B,255
	LD	(IY+15),B
	LD	(IY+16),B
	LD	(IY+17),B
	LD	(IY+18),B
; 2090.	        fs->free_clust = 0xFFFFFFFF;
	XOR	A
	LD	(IY+11),A
	LD	(IY+12),A
	LD	(IY+13),A
	LD	(IY+14),A
; 2091.	        fs->last_clust = 0;
; 2092.	
; 2093.	        /* Get fsinfo if available */
	LD	A,(IX-32)
	CP	3
	JP	NZ,?0453
?0450:
; 2094.	        if (fmt == FS_FAT32) {
	LD	(IY+6),0
; 2095.	                fs->fsi_flag = 0;
	LD	HL,51
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	DE,48
	ADD	HL,DE
	LD	D,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,D
	LD	BC,0
	PUSH	BC
	PUSH	HL
	LD	L,(IX-24)
	LD	H,(IX-23)
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	LD	L,(IX-22)
	LD	H,(IX-21)
	POP	BC
	ADC	HL,BC
	LD	C,L
	LD	B,H
	EX	DE,HL
	LD	(IY+19),L
	LD	(IY+20),H
	LD	(IY+21),C
	LD	(IY+22),B
; 2096.	                fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
	LD	A,(IY+1)
	LD	(dio_par),A
	LD	HL,51
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	(dio_par+1),HL
	LD	HL,19
	ADD	HL,BC
; 2097.	                SET_DIO_PAR(fs->drv, fs->win, fs->fsi_sector,1);
; 2098.	                if (disk_read() == RES_OK &&
; 2099.	                        LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
; 2100.	                        LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
	CALL	?1041
	JP	NZ,?0453
	LD	HL,51
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	BC,510
	ADD	HL,BC
	LD	B,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,B
	LD	BC,43605
	AND	A
	SBC	HL,BC
	JR	NZ,?0453
	LD	L,(IY+51)
	LD	H,(IY+52)
	LD	BC,21074
	AND	A
	SBC	HL,BC
	JR	NZ,?0453
	LD	L,(IY+53)
	LD	H,(IY+54)
	LD	BC,16737
	SBC	HL,BC
	JR	NZ,?0453
	LD	HL,51
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	BC,484
	ADD	HL,BC
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	L,C
	LD	H,B
	LD	BC,29298
	AND	A
	SBC	HL,BC
	JR	NZ,?0453
	EX	DE,HL
	LD	BC,24897
	SBC	HL,BC
	JR	NZ,?0453
?0455:
?0454:
?0452:
; 2101.	                        LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
	LD	HL,51
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	DE,492
	ADD	HL,DE
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	(IY+11),C
	LD	(IY+12),B
	LD	(IY+13),E
	LD	(IY+14),D
; 2102.	                                fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
	LD	HL,51
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	DE,488
	ADD	HL,DE
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	(IY+15),C
	LD	(IY+16),B
	LD	(IY+17),E
	LD	(IY+18),D
?0453:
?0451:
; 2103.	                                fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
; 2104.	                }
; 2105.	        }
; 2106.	#endif
	LD	B,(IX-32)
	LD	(IY+0),B
; 2107.	        fs->fs_type = fmt;              /* FAT sub-type */
	LD	HL,(Fsid)
	INC	HL
	LD	(Fsid),HL
	LD	(IY+7),L
	LD	(IY+8),H
; 2108.	        fs->id = ++Fsid;                /* File system mount ID */
	XOR	A
	LD	(IY+47),A
	LD	(IY+48),A
	LD	(IY+49),A
	LD	(IY+50),A
; 2109.	        fs->winsect = 0;                /* Invalidate sector cache */
	LD	(IY+5),A
; 2110.	        fs->wflag = 0;
; 2111.	#if _FS_RPATH
	LD	(IY+23),A
	LD	(IY+24),A
	LD	(IY+25),A
	LD	(IY+26),A
; 2112.	        fs->cdir = 0;                   /* Current directory (root dir) */
; 2113.	#endif
; 2114.	#if _FS_SHARE                           /* Clear file lock semaphores */
; 2116.	#endif
; 2117.	
?0968:
	XOR	A
; 2118.	        return FR_OK;
?0456:
	JP	?0154
?1059:
	ADC	HL,BC
?1058:
	LD	C,L
	LD	B,H
	EX	DE,HL
	JP	?UL_DIV_L03
; 2119.	}
; 2120.	
; 2121.	
; 2122.	
; 2123.	
; 2124.	/*-----------------------------------------------------------------------*/
; 2125.	/* Check if the file/dir object is valid or not                          */
; 2126.	/*-----------------------------------------------------------------------*/
; 2127.	
; 2128.	static
; 2129.	FRESULT validate (      /* FR_OK(0): The object is valid, !=0: Invalid */
; 2130.	        FATFS *fs,              /* Pointer to the file system object */
; 2131.	        WORD id                 /* Member id of the target object to be checked */
; 2132.	)
validate:
	PUSH	IX
	PUSH	BC
	PUSH	DE
	POP	IX
; 2133.	{
	LD	A,E
	OR	D
	JR	Z,?0459
	XOR	A
	OR	(IX+0)
	JR	Z,?0459
	LD	L,(IX+7)
	LD	H,(IX+8)
	SBC	HL,BC
	JR	Z,?0458
?0459:
?0460:
?0457:
; 2134.	        if (!fs || !fs->fs_type || fs->id != id)
	LD	A,9
; 2135.	                return FR_INVALID_OBJECT;
; 2136.	
	JR	?0463
?0458:
; 2137.	        ENTER_FF(fs);           /* Lock file system */
; 2138.	
	LD	C,(IX+1)
	LD	B,0
	LD	HL,ds_m
	ADD	HL,BC
	BIT	0,(HL)
	JR	Z,?0462
?0461:
; 2139.	        if (disk_status(fs->drv) & STA_NOINIT)
	LD	A,3
; 2140.	                return FR_NOT_READY;
; 2141.	
	JR	?0463
?0462:
	XOR	A
; 2142.	        return FR_OK;
?0463:
	POP	HL
	POP	IX
	RET
; 2143.	}
; 2144.	
; 2145.	
; 2146.	
; 2147.	
; 2148.	/*--------------------------------------------------------------------------
; 2149.	
; 2150.	   Public Functions
; 2151.	
; 2152.	--------------------------------------------------------------------------*/
; 2153.	
; 2154.	
; 2155.	
; 2156.	/*-----------------------------------------------------------------------*/
; 2157.	/* Mount/Unmount a Logical Drive                                         */
; 2158.	/*-----------------------------------------------------------------------*/
; 2159.	
; 2160.	FRESULT f_mount (
; 2161.	        BYTE vol,               /* Logical drive number to be mounted/unmounted */
; 2162.	        FATFS *fs               /* Pointer to new file system object (NULL for unmount)*/
; 2163.	)
f_mount:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	0
	PUSH	IY
	LD	E,C
	LD	D,B
; 2164.	{
; 2165.	        FATFS *rfs;
; 2166.	
; 2167.	
	LD	A,(IX+2)
	CP	2
	JR	C,?0465
?0464:
; 2168.	        if (vol >= _VOLUMES)                    /* Check if the drive number is valid */
	LD	A,11
; 2169.	                return FR_INVALID_DRIVE;
	JR	?0470
?0465:
	LD	L,A
	LD	H,0
	ADD	HL,HL
	LD	BC,FatFs
	ADD	HL,BC
	LD	B,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,B
	PUSH	HL
	POP	IY
; 2170.	        rfs = FatFs[vol];                               /* Get current fs object */
; 2171.	
	LD	A,L
	OR	H
	JR	Z,?0467
?0466:
; 2172.	        if (rfs) {
; 2173.	#if _FS_SHARE
; 2175.	#endif
; 2176.	#if _FS_REENTRANT                                       /* Discard sync object of the current volume */
; 2178.	#endif
	LD	(IY+0),0
?0467:
; 2179.	                rfs->fs_type = 0;                       /* Clear old fs object */
; 2180.	        }
; 2181.	
	LD	A,E
	OR	D
	JR	Z,?0469
?0468:
; 2182.	        if (fs) {
	LD	L,E
	LD	H,D
	LD	(HL),0
?0469:
; 2183.	                fs->fs_type = 0;                        /* Clear new fs object */
; 2184.	#if _FS_REENTRANT                                       /* Create sync object for the new volume */
; 2186.	#endif
; 2187.	        }
	LD	L,(IX+2)
	LD	H,0
	ADD	HL,HL
	LD	BC,FatFs
	ADD	HL,BC
	LD	(HL),E
	INC	HL
	LD	(HL),D
; 2188.	        FatFs[vol] = fs;                                /* Register new fs object */
; 2189.	
	XOR	A
; 2190.	        return FR_OK;
?0470:
	POP	IY
	JP	?LEAVE_DIRECT_L09
; 2191.	}
; 2192.	
; 2193.	
; 2194.	
; 2195.	
; 2196.	/*-----------------------------------------------------------------------*/
; 2197.	/* Open or Create a File                                                 */
; 2198.	/*-----------------------------------------------------------------------*/
; 2199.	
; 2200.	FRESULT f_open (
; 2201.	        FIL *fp,                        /* Pointer to the blank file object */
; 2202.	        const TCHAR *path,      /* Pointer to the file name */
; 2203.	        BYTE mode                       /* Access mode and file open mode flags */
; 2204.	)
f_open:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	65490
	PUSH	IY
	EXX
	PUSH	BC
	LD	C,(IX+2)
	LD	B,(IX+3)
; 2205.	{
; 2206.	        FRESULT res;
; 2207.	        DIR dj;
; 2208.	        BYTE *dir;
; 2209.	        DEF_NAMEBUF;
; 2210.	
; 2211.	
	PUSH	BC
	EXX
	POP	HL
	XOR	A
	LD	(HL),A
	INC	HL
	LD	(HL),A
; 2212.	        fp->fs = 0;                     /* Clear file object */
; 2213.	
; 2214.	#if !_FS_READONLY
	LD	A,(IX+8)
	AND	31
	LD	(IX+8),A
; 2215.	        mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	RES	0,A
	LD	C,A
	PUSH	BC
	LD	HL,7
	ADD	HL,SP
	LD	C,L
	LD	B,H
	LD	HL,56
	ADD	HL,SP
	CALL	?1060
	POP	HL
	LD	(IX-46),A
; 2216.	        res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
; 2217.	#else
; 2220.	#endif
	LD	HL,29
	ADD	HL,SP
	LD	(IX-25),L
	LD	(IX-24),H
; 2221.	        INIT_BUF(dj);
	OR	A
	JR	NZ,?0472
?0471:
; 2222.	        if (res == FR_OK)
	LD	C,(IX+4)
	LD	B,(IX+5)
	LD	HL,5
	ADD	HL,SP
	EX	DE,HL
	CALL	follow_path
	LD	(IX-46),A
?0472:
; 2223.	                res = follow_path(&dj, path);   /* Follow the file path */
	LD	L,(IX-27)
	LD	H,(IX-26)
	PUSH	HL
	POP	IY
; 2224.	        dir = dj.dir;
; 2225.	
; 2226.	#if !_FS_READONLY       /* R/W configuration */
	XOR	A
	OR	(IX-46)
	JR	NZ,?0476
?0473:
; 2227.	        if (res == FR_OK) {
	LD	A,IYL
	OR	IYH
	JR	NZ,?0476
?0475:
; 2228.	                if (!dir)       /* Current dir itself */
	LD	(IX-46),6
?0476:
?0474:
; 2229.	                        res = FR_INVALID_NAME;
; 2230.	#if _FS_SHARE
; 2233.	#endif
; 2234.	        }
; 2235.	        /* Create or Open a file */
	LD	A,(IX+8)
	AND	28
	JP	Z,?0478
?0477:
; 2236.	        if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
; 2237.	                DWORD dw, cl;
; 2238.	
	XOR	A
	OR	(IX-46)
	JR	Z,?0480
?0479:
; 2239.	                if (res != FR_OK) {                                     /* No file, create new */
	CP	4
	JR	NZ,?0482
?0481:
; 2240.	                        if (res == FR_NO_FILE)                  /* There is no file to open, create a new entry */
; 2241.	#if _FS_SHARE
; 2243.	#else
	LD	HL,5
	ADD	HL,SP
	EX	DE,HL
	CALL	dir_register
	LD	(IX-46),A
?0482:
; 2244.	                                res = dir_register(&dj);
; 2245.	#endif
	SET	3,(IX+8)
; 2246.	                        mode |= FA_CREATE_ALWAYS;               /* File is created */
	LD	L,(IX-27)
	LD	H,(IX-26)
	PUSH	HL
	POP	IY
; 2247.	                        dir = dj.dir;                                   /* New entry */
; 2248.	                }
	JR	?0488
?0480:
; 2249.	                else {                                                          /* Any object is already existing */
	LD	A,(IY+11)
	AND	17
	JR	Z,?0485
?0484:
; 2250.	                        if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {        /* Cannot overwrite it (R/O or DIR) */
	LD	(IX-46),7
; 2251.	                                res = FR_DENIED;
	JR	?0488
?0485:
; 2252.	                        } else {
	BIT	2,(IX+8)
	JR	Z,?0488
?0487:
; 2253.	                                if (mode & FA_CREATE_NEW)       /* Cannot create as new file */
	LD	(IX-46),8
?0488:
?0486:
?0483:
; 2254.	                                        res = FR_EXIST;
; 2255.	                        }
; 2256.	                }
	XOR	A
	OR	(IX-46)
	JP	NZ,?0504
	BIT	3,(IX+8)
	JP	Z,?0504
?0492:
?0491:
?0489:
; 2257.	                if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {        /* Truncate it if overwrite mode */
	LD	HL,41
	ADD	HL,SP
	EX	DE,HL
	CALL	get_fattime
; 2258.	                        get_fattime(&dw);                                       /* Created time */
	LD	C,(IX-7)
	LD	B,(IX-6)
	LD	L,(IX-9)
	LD	(IY+14),L
	LD	H,(IX-8)
	LD	(IY+15),H
	LD	(IY+16),C
	LD	(IY+17),B
; 2259.	                        ST_DWORD(dir+DIR_CrtTime, dw);
	LD	(IY+11),0
; 2260.	                        dir[DIR_Attr] = 0;                                      /* Reset attribute */
	XOR	A
	LD	(IY+28),A
	LD	(IY+29),A
	LD	(IY+30),A
	LD	(IY+31),A
; 2261.	                        ST_DWORD(dir+DIR_FileSize, 0);          /* size = 0 */
	PUSH	IY
	POP	DE
	CALL	LD_CLUST
	LD	(IX-5),L
	LD	(IX-4),H
	LD	(IX-3),C
	LD	(IX-2),B
; 2262.	                        cl = LD_CLUST(dir);                                     /* Get start cluster */
	XOR	A
	LD	(IY+26),A
	LD	(IY+27),A
	LD	(IY+20),A
	LD	(IY+21),A
; 2263.	                        ST_CLUST(dir, 0);                                       /* cluster = 0 */
	LD	HL,5
	LD	C,(IX-45)
	LD	B,(IX-44)
	ADD	HL,BC
	LD	(HL),1
; 2264.	                        dj.fs->wflag = 1;
	LD	A,(IX-5)
	OR	(IX-4)
	OR	(IX-3)
	OR	(IX-2)
	JP	Z,?0504
?0493:
; 2265.	                        if (cl) {                                                       /* Remove the cluster chain if exist */
	LD	HL,47
	LD	C,(IX-45)
	LD	B,(IX-44)
	ADD	HL,BC
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	EX	DE,HL
	LD	(IX-9),L
	LD	(IX-8),H
	LD	(IX-7),C
	LD	(IX-6),B
; 2266.	                                dw = dj.fs->winsect;
	LD	L,(IX-3)
	LD	H,(IX-2)
	PUSH	HL
	LD	L,(IX-5)
	LD	H,(IX-4)
	PUSH	HL
	LD	E,(IX-45)
	LD	D,(IX-44)
	CALL	remove_chain
	POP	HL
	POP	HL
	LD	(IX-46),A
; 2267.	                                res = remove_chain(dj.fs, cl);
	OR	A
	JR	NZ,?0504
?0495:
; 2268.	                                if (res == FR_OK) {
	LD	HL,11
	LD	C,(IX-45)
	LD	B,(IX-44)
	ADD	HL,BC
	PUSH	HL
	LD	BC,65535
	PUSH	BC
	PUSH	BC
	LD	L,(IX-5)
	LD	H,(IX-4)
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	LD	L,(IX-3)
	LD	H,(IX-2)
	POP	BC
	ADC	HL,BC
	LD	C,L
	LD	B,H
	POP	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	LD	(HL),C
	INC	HL
	LD	(HL),B
; 2269.	                                        dj.fs->last_clust = cl - 1;     /* Reuse the cluster hole */
	LD	L,(IX-7)
	LD	H,(IX-6)
	PUSH	HL
	LD	L,(IX-9)
	LD	H,(IX-8)
	PUSH	HL
	LD	E,(IX-45)
	LD	D,(IX-44)
	CALL	move_window
	POP	HL
	POP	HL
	LD	(IX-46),A
?0496:
?0494:
?0490:
; 2270.	                                        res = move_window(dj.fs, dw);
; 2271.	                                }
; 2272.	                        }
; 2273.	                }
; 2274.	        }
	JR	?0504
?0478:
; 2275.	        else {  /* Open an existing file */
	OR	(IX-46)
	JR	NZ,?0504
?0498:
; 2276.	                if (res == FR_OK) {                                             /* Follow succeeded */
	BIT	4,(IY+11)
	JR	Z,?0501
?0500:
; 2277.	                        if (dir[DIR_Attr] & AM_DIR) {           /* It is a directory */
	LD	(IX-46),4
; 2278.	                                res = FR_NO_FILE;
	JR	?0504
?0501:
; 2279.	                        } else {
	BIT	1,(IX+8)
	JR	Z,?0504
	BIT	0,(IY+11)
	JR	Z,?0504
?0506:
?0505:
?0503:
; 2280.	                                if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
	LD	(IX-46),7
?0504:
?0502:
?0499:
?0497:
; 2281.	                                        res = FR_DENIED;
; 2282.	                        }
; 2283.	                }
; 2284.	        }
	XOR	A
	OR	(IX-46)
	JR	NZ,?0508
?0507:
; 2285.	        if (res == FR_OK) {
	BIT	3,(IX+8)
	JR	Z,?0510
?0509:
; 2286.	                if (mode & FA_CREATE_ALWAYS)                    /* Set file change flag if created or overwritten */
	SET	5,(IX+8)
?0510:
; 2287.	                        mode |= FA__WRITTEN;
	LD	HL,47
	LD	C,(IX-45)
	LD	B,(IX-44)
	ADD	HL,BC
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	EX	DE,HL
	PUSH	HL
	LD	HL,26
	EXX
	PUSH	BC
	EXX
	POP	DE
	ADD	HL,DE
	POP	DE
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	LD	(HL),C
	INC	HL
	LD	(HL),B
; 2288.	                fp->dir_sect = dj.fs->winsect;                  /* Pointer to the directory entry */
	LD	HL,30
	EXX
	PUSH	BC
	EXX
	POP	BC
	ADD	HL,BC
	PUSH	IY
	POP	BC
	LD	(HL),C
	INC	HL
	LD	(HL),B
?0508:
; 2289.	                fp->dir_ptr = dir;
; 2290.	#if _FS_SHARE
; 2293.	#endif
; 2294.	        }
; 2295.	
; 2296.	#else                           /* R/O configuration */
; 2305.	#endif
; 2306.	        FREE_BUF();
; 2307.	
	XOR	A
	OR	(IX-46)
	JP	NZ,?0512
?0511:
; 2308.	        if (res == FR_OK) {
	LD	HL,4
	EXX
	PUSH	BC
	EXX
	POP	BC
	ADD	HL,BC
	LD	D,(IX+8)
	LD	(HL),D
; 2309.	                fp->flag = mode;                                        /* File access mode */
	PUSH	IY
	POP	DE
	CALL	LD_CLUST
	PUSH	HL
	LD	HL,14
	EXX
	PUSH	BC
	EXX
	POP	DE
	ADD	HL,DE
	POP	DE
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	LD	(HL),C
	INC	HL
	LD	(HL),B
; 2310.	                fp->sclust = LD_CLUST(dir);                     /* File start cluster */
	LD	C,(IY+30)
	LD	B,(IY+31)
	LD	L,(IY+28)
	LD	H,(IY+29)
	PUSH	HL
	LD	HL,10
	EXX
	PUSH	BC
	EXX
	POP	DE
	ADD	HL,DE
	POP	DE
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	LD	(HL),C
	INC	HL
	LD	(HL),B
; 2311.	                fp->fsize = LD_DWORD(dir+DIR_FileSize); /* File size */
	LD	HL,6
	EXX
	PUSH	BC
	EXX
	POP	BC
	ADD	HL,BC
	XOR	A
	LD	(HL),A
	INC	HL
	LD	(HL),A
	INC	HL
	LD	(HL),A
	INC	HL
	LD	(HL),A
; 2312.	                fp->fptr = 0;                                           /* File pointer */
	LD	HL,22
	ADD	HL,BC
	LD	(HL),A
	INC	HL
	LD	(HL),A
	INC	HL
	LD	(HL),A
	INC	HL
	LD	(HL),A
; 2313.	                fp->dsect = 0;
; 2314.	#if _USE_FASTSEEK
; 2316.	#endif
	LD	L,(IX-45)
	LD	H,(IX-44)
	PUSH	HL
	LD	L,C
	LD	H,B
	POP	BC
	LD	(HL),C
	INC	HL
	LD	(HL),B
	EXX
	PUSH	BC
	EXX
	POP	HL
	INC	HL
	INC	HL
	PUSH	HL
	LD	HL,7
	LD	C,(IX-45)
	LD	B,(IX-44)
	ADD	HL,BC
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	POP	HL
	LD	(HL),C
	INC	HL
	LD	(HL),B
?0512:
; 2317.	                fp->fs = dj.fs; fp->id = dj.fs->id;     /* Validate file object */
; 2318.	        }
; 2319.	
	LD	A,(IX-46)
; 2320.	        LEAVE_FF(dj.fs, res);
	JP	?0190
?1060:
	EX	DE,HL
	JP	chk_mounted
; 2321.	}
; 2322.	
; 2323.	
; 2324.	
; 2325.	
; 2326.	/*-----------------------------------------------------------------------*/
; 2327.	/* Read File                                                             */
; 2328.	/*-----------------------------------------------------------------------*/
; 2329.	
; 2330.	FRESULT f_read (
; 2331.	        FIL *fp,                /* Pointer to the file object */
; 2332.	        void *buff,             /* Pointer to data buffer */
; 2333.	        UINT btr,               /* Number of bytes to read */
; 2334.	        UINT *br                /* Pointer to number of bytes read */
; 2335.	)
f_read:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	-16
	PUSH	IY
	EXX
	PUSH	BC
	PUSH	DE
	EXX
	LD	L,(IX+2)
	LD	H,(IX+3)
	PUSH	HL
	POP	IY
; 2336.	{
; 2337.	        FRESULT res;
; 2338.	        DWORD clst, sect, remain;
; 2339.	        UINT rcnt, cc;
	LD	(IX-12),C
	LD	(IX-11),B
; 2340.	        BYTE csect, *rbuff = buff;
; 2341.	
; 2342.	
	LD	L,(IX+10)
	LD	H,(IX+11)
	XOR	A
	LD	(HL),A
	INC	HL
	LD	(HL),A
; 2343.	        *br = 0;        /* Initialize byte counter */
; 2344.	
	CALL	?1064
; 2345.	        res = validate(fp->fs, fp->id);                         /* Check validity */
	OR	A
	JP	NZ,?0521
?0513:
; 2346.	        if (res != FR_OK) LEAVE_FF(fp->fs, res);
?0514:
	LD	A,(IY+4)
	OR	A
	JP	M,?0986
?0515:
; 2347.	        if (fp->flag & FA__ERROR)                                       /* Aborted file? */
; 2348.	                LEAVE_FF(fp->fs, FR_INT_ERR);
?0516:
	BIT	0,(IY+4)
	JR	NZ,?0518
?0517:
; 2349.	        if (!(fp->flag & FA_READ))                                      /* Check access mode */
	LD	A,7
; 2350.	                LEAVE_FF(fp->fs, FR_DENIED);
	JP	?0521
?0518:
	AND	A
	LD	L,(IY+10)
	LD	H,(IY+11)
	LD	C,(IY+6)
	LD	B,(IY+7)
	SBC	HL,BC
	EX	DE,HL
	LD	L,(IY+12)
	LD	H,(IY+13)
	LD	C,(IY+8)
	LD	B,(IY+9)
	SBC	HL,BC
	LD	C,L
	LD	B,H
	EX	DE,HL
	LD	(IX-6),L
	LD	(IX-5),H
	LD	(IX-4),C
	LD	(IX-3),B
; 2351.	        remain = fp->fsize - fp->fptr;
	LD	E,(IX+8)
	LD	D,(IX+9)
	LD	BC,0
	PUSH	BC
	PUSH	DE
	AND	A
	POP	BC
	SBC	HL,BC
	LD	L,(IX-4)
	LD	H,(IX-3)
	POP	BC
	SBC	HL,BC
	JR	NC,?0520
?0519:
	LD	L,(IX-6)
	LD	H,(IX-5)
	LD	(IX+8),L
	LD	(IX+9),H
?0520:
?0522:
; 2352.	        if (btr > remain) btr = (UINT)remain;           /* Truncate btr by remaining bytes */
; 2353.	
	LD	A,(IX+8)
	OR	(IX+9)
	JP	Z,?0521
?0523:
; 2355.	                rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
	LD	L,(IY+6)
	LD	A,(IY+7)
	AND	1
	LD	H,A
	LD	A,L
	OR	H
	JP	NZ,?0526
?0525:
; 2356.	                if ((fp->fptr % SS(fp->fs)) == 0) {             /* On the sector boundary? */
	LD	C,(IY+8)
	LD	B,(IY+9)
	LD	L,(IY+6)
	LD	H,(IY+7)
	LD	A,9
	CALL	?UL_RSH_L03
	PUSH	HL
	LD	L,(IY+0)
	LD	H,(IY+1)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	ADD	A,255
	POP	HL
	AND	L
	LD	(IX-2),A
; 2357.	                        csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));    /* Sector offset in the cluster */
	JR	NZ,?0528
?0527:
; 2358.	                        if (!csect) {                                           /* On the cluster boundary? */
	LD	A,(IY+6)
	OR	(IY+7)
	OR	(IY+8)
	OR	(IY+9)
	JR	NZ,?0530
?0529:
; 2359.	                                if (fp->fptr == 0) {                    /* On the top of the file? */
	LD	C,(IY+16)
	LD	B,(IY+17)
	LD	L,(IY+14)
	LD	H,(IY+15)
	JR	?0984
; 2360.	                                        clst = fp->sclust;                      /* Follow from the origin */
?0530:
; 2361.	                                } else {                                                /* Middle or end of the file */
; 2362.	#if _USE_FASTSEEK
; 2366.	#endif
	LD	L,(IY+20)
	LD	H,(IY+21)
	PUSH	HL
	LD	L,(IY+18)
	LD	H,(IY+19)
	PUSH	HL
	CALL	?1049
	POP	AF
	POP	AF
?0984:
	LD	(IX-10),L
	LD	(IX-9),H
	LD	(IX-8),C
	LD	(IX-7),B
?0531:
; 2367.	                                                clst = get_fat(fp->fs, fp->clust);      /* Follow cluster chain on the FAT */
; 2368.	                                }
	AND	A
	LD	BC,2
	SBC	HL,BC
	LD	L,(IX-8)
	LD	H,(IX-7)
	DEC	BC
	DEC	BC
	SBC	HL,BC
	JR	C,?0990
?0532:
?0533:
; 2369.	                                if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
	LD	A,(IX-10)
	AND	(IX-9)
	AND	(IX-8)
	AND	(IX-7)
	INC	A
	JP	Z,?0989
?0534:
?0535:
; 2370.	                                if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
	LD	C,(IX-8)
	LD	B,(IX-7)
	LD	L,(IX-10)
	LD	(IY+18),L
	LD	H,(IX-9)
	LD	(IY+19),H
	LD	(IY+20),C
	LD	(IY+21),B
?0528:
; 2371.	                                fp->clust = clst;                               /* Update current cluster */
; 2372.	                        }
	LD	L,(IY+20)
	LD	H,(IY+21)
	PUSH	HL
	LD	L,(IY+18)
	LD	H,(IY+19)
	PUSH	HL
	CALL	?1052
	POP	AF
	POP	AF
	LD	(IX-16),L
	LD	(IX-15),H
	LD	(IX-14),C
	LD	(IX-13),B
; 2373.	                        sect = clust2sect(fp->fs, fp->clust);   /* Get current sector */
	LD	A,L
	OR	H
	OR	C
	OR	B
	JR	NZ,?0537
?0536:
?0990:
	SET	7,(IY+4)
?0986:
	LD	A,2
	JP	?0521
?0537:
; 2374.	                        if (!sect) ABORT(fp->fs, FR_INT_ERR);
	LD	HL,6
	ADD	HL,SP
	CALL	?1040
; 2375.	                        sect += csect;
	PUSH	DE
	EXX
	POP	DE
	EXX
; 2376.	                        cc = btr / SS(fp->fs);                          /* When remaining bytes >= sector size, */
	LD	A,E
	OR	D
	JP	Z,?0539
?0538:
; 2377.	                        if (cc) {                                                       /* Read maximum contiguous sectors directly */
	LD	C,(IX-2)
	LD	B,0
	EXX
	PUSH	DE
	EXX
	POP	HL
	ADD	HL,BC
	LD	C,L
	LD	B,H
	LD	L,(IY+0)
	LD	H,(IY+1)
	INC	HL
	INC	HL
	INC	HL
	LD	L,(HL)
	LD	H,0
	AND	A
	SBC	HL,BC
	JR	NC,?0541
?0540:
; 2378.	                                if (csect + cc > fp->fs->csize) /* Clip at cluster boundary */
	LD	C,(IX-2)
	LD	B,0
	LD	L,(IY+0)
	LD	H,(IY+1)
	INC	HL
	INC	HL
	INC	HL
	LD	L,(HL)
	LD	H,B
	AND	A
	SBC	HL,BC
	PUSH	HL
	EXX
	POP	DE
	EXX
?0541:
; 2379.	                                        cc = fp->fs->csize - csect;
	LD	L,(IY+0)
	LD	H,(IY+1)
	INC	HL
	LD	A,(HL)
	LD	(dio_par),A
	LD	L,(IX-12)
	LD	H,(IX-11)
	LD	(dio_par+1),HL
	LD	HL,6
	ADD	HL,SP
	LD	(dio_par+3),HL
	EXX
	PUSH	DE
	EXX
	POP	HL
	LD	A,L
; 2380.	                                SET_DIO_PAR(fp->fs->drv, rbuff, sect, (BYTE)cc);
	CALL	?1042
	JP	NZ,?0989
?0542:
; 2381.	                                if (disk_read() != RES_OK)
?0543:
; 2382.	                                        ABORT(fp->fs, FR_DISK_ERR);
; 2383.	#if !_FS_READONLY && _FS_MINIMIZE <= 2                  /* Replace one of the read sectors with cached data if it contains a dirty sector */
; 2384.	#if _FS_TINY
; 2387.	#else
	BIT	6,(IY+4)
	JR	Z,?0547
	EXX
	PUSH	DE
	EXX
	POP	HL
	LD	C,A
	LD	B,A
	PUSH	BC
	PUSH	HL
	AND	A
	LD	L,(IY+22)
	LD	H,(IY+23)
	LD	C,(IX-16)
	LD	B,(IX-15)
	SBC	HL,BC
	EX	DE,HL
	LD	L,(IY+24)
	LD	H,(IY+25)
	LD	C,(IX-14)
	LD	B,(IX-13)
	SBC	HL,BC
	EX	DE,HL
	AND	A
	POP	BC
	SBC	HL,BC
	EX	DE,HL
	POP	BC
	SBC	HL,BC
	JR	NC,?0547
?0549:
?0548:
?0546:
; 2388.	                                if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
	LD	BC,512
	LD	E,(IX-16)
	LD	D,(IX-15)
	LD	L,(IY+22)
	LD	H,(IY+23)
	AND	A
	SBC	HL,DE
	LD	H,L
	LD	L,C
	ADD	HL,HL
	LD	E,(IX-12)
	LD	D,(IX-11)
	ADD	HL,DE
	EX	DE,HL
	LD	HL,32
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	BC,512
	LDIR
?0547:
; 2389.	                                        memcpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
; 2390.	#endif
; 2391.	#endif
	EXX
	PUSH	DE
	EXX
	POP	HL
	LD	H,L
	LD	L,A
	ADD	HL,HL
	PUSH	HL
	EXX
	POP	BC
	EXX
; 2392.	                                rcnt = SS(fp->fs) * cc;                 /* Number of bytes transferred */
	JP	?0983
?0539:
; 2393.	                                continue;
; 2394.	                        }
; 2395.	#if !_FS_TINY
	LD	L,(IY+22)
	LD	H,(IY+23)
	LD	C,(IX-16)
	LD	B,(IX-15)
	SBC	HL,BC
	JR	NZ,?0982
	LD	L,(IY+24)
	LD	H,(IY+25)
	LD	C,(IX-14)
	LD	B,(IX-13)
	SBC	HL,BC
	JR	Z,?0557
?0982:
?0550:
; 2396.	                        if (fp->dsect != sect) {                        /* Load data sector if not in cache */
; 2397.	#if !_FS_READONLY
	BIT	6,(IY+4)
	JR	Z,?0553
?0552:
; 2398.	                                if (fp->flag & FA__DIRTY) {             /* Write-back dirty sector cache */
; 2399.	                                        SET_DIO_PAR(fp->fs->drv, fp->buf, fp->dsect, 1);
	CALL	?1038
	OR	A
	JR	NZ,?0989
?0554:
; 2400.	                                        if (disk_write() != RES_OK)
?0555:
; 2401.	                                                ABORT(fp->fs, FR_DISK_ERR);
	RES	6,(IY+4)
?0553:
; 2402.	                                        fp->flag &= ~FA__DIRTY;
; 2403.	                                }
; 2404.	                                
	LD	L,(IY+0)
	LD	H,(IY+1)
	INC	HL
	LD	A,(HL)
	LD	(dio_par),A
	LD	HL,32
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	(dio_par+1),HL
	LD	HL,6
	ADD	HL,SP
; 2405.	                                SET_DIO_PAR(fp->fs->drv, fp->buf, sect, 1);
	CALL	?1041
	JR	Z,?0557
?0556:
; 2406.	                                if (disk_read() != RES_OK)      /* Fill sector cache */
?0989:
	SET	7,(IY+4)
	LD	A,1
	JP	?0521
?0557:
?0551:
; 2407.	                                        ABORT(fp->fs, FR_DISK_ERR);
; 2408.	                        }
; 2409.	#endif
	LD	C,(IX-14)
	LD	B,(IX-13)
	LD	L,(IX-16)
	LD	(IY+22),L
	LD	H,(IX-15)
	LD	(IY+23),H
	LD	(IY+24),C
	LD	(IY+25),B
?0526:
; 2410.	                        fp->dsect = sect;
; 2411.	                }
	LD	C,(IY+6)
	LD	A,(IY+7)
	AND	1
	LD	B,A
	LD	HL,512
	SBC	HL,BC
	PUSH	HL
	EXX
	POP	BC
	EXX
; 2412.	                rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));    /* Get partial sector data from sector buffer */
	LD	C,L
	LD	B,H
	LD	L,(IX+8)
	LD	H,(IX+9)
	AND	A
	SBC	HL,BC
	JR	NC,?0559
?0558:
	EXX
	LD	C,(IX+8)
	LD	B,(IX+9)
	EXX
?0559:
; 2413.	                if (rcnt > btr) rcnt = btr;
; 2414.	#if _FS_TINY
; 2418.	#else
	EXX
	PUSH	BC
	EXX
	LD	E,(IX-12)
	LD	D,(IX-11)
	LD	L,(IY+6)
	LD	A,(IY+7)
	AND	1
	LD	H,A
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	BC,32
	ADD	HL,BC
	POP	BC
	LD	A,C
	OR	B
	JR	Z,?0983
	LDIR
?0983:
?0524:
; 2354.	        for ( ;  btr;                                                           /* Repeat until all data read */
	LD	HL,10
	ADD	HL,SP
	EXX
	PUSH	BC
	EXX
	POP	BC
	LD	A,(HL)
	ADD	A,C
	LD	(HL),A
	INC	HL
	LD	A,(HL)
	ADC	A,B
	LD	(HL),A
	LD	HL,6
	PUSH	IY
	POP	BC
	ADD	HL,BC
	EXX
	PUSH	BC
	EXX
	POP	DE
	LD	BC,0
	CALL	?L_ADDASG_L03
	EXX
	PUSH	BC
	EXX
	POP	BC
	LD	L,(IX+10)
	LD	H,(IX+11)
	LD	A,(HL)
	ADD	A,C
	LD	(HL),A
	INC	HL
	LD	A,(HL)
	ADC	A,B
	LD	(HL),A
	LD	HL,30
	ADD	HL,SP
	LD	A,(HL)
	SUB	C
	LD	(HL),A
	INC	HL
	LD	A,(HL)
	SBC	A,B
	LD	(HL),A
; 2419.	                memcpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);   /* Pick partial sector */
; 2420.	#endif
; 2421.	        }
; 2422.	
	JP	?0520
?0521:
; 2423.	        LEAVE_FF(fp->fs, FR_OK);
?0560:
	JP	?0154
?1040:
	LD	E,(IX-2)
	LD	BC,0
	LD	D,C
	CALL	?L_ADDASG_L03
	LD	B,9
	LD	E,(IX+8)
	LD	D,(IX+9)
	CALL	?US_RSH_L02
	RET
?1065:
	LD	L,(IX+2)
	LD	H,(IX+3)
	PUSH	HL
	POP	IY
?1064:
	LD	C,(IY+2)
	LD	B,(IY+3)
	LD	E,(IY+0)
	LD	D,(IY+1)
	JP	validate
; 2424.	}
; 2425.	
; 2426.	
; 2427.	
; 2428.	
; 2429.	#if !_FS_READONLY
; 2430.	/*-----------------------------------------------------------------------*/
; 2431.	/* Write File                                                            */
; 2432.	/*-----------------------------------------------------------------------*/
; 2433.	
; 2434.	FRESULT f_write (
; 2435.	        FIL *fp,                        /* Pointer to the file object */
; 2436.	        const void *buff,       /* Pointer to the data to be written */
; 2437.	        UINT btw,                       /* Number of bytes to write */
; 2438.	        UINT *bw                        /* Pointer to number of bytes written */
; 2439.	)
f_write:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	-12
	PUSH	IY
	EXX
	PUSH	BC
	PUSH	DE
	EXX
	LD	L,(IX+2)
	LD	H,(IX+3)
	PUSH	HL
	POP	IY
; 2440.	{
; 2441.	        FRESULT res;
; 2442.	        DWORD clst, sect;
; 2443.	        UINT wcnt, cc;
	LD	(IX-4),C
	LD	(IX-3),B
; 2444.	        const BYTE *wbuff = buff;
; 2445.	        BYTE csect;
; 2446.	
; 2447.	
	LD	L,(IX+10)
	LD	H,(IX+11)
	XOR	A
	LD	(HL),A
	INC	HL
	LD	(HL),A
; 2448.	        *bw = 0;        /* Initialize byte counter */
; 2449.	
	CALL	?1064
; 2450.	        res = validate(fp->fs, fp->id);                 /* Check validity */
	OR	A
	JP	NZ,?0612
?0561:
; 2451.	        if (res != FR_OK) LEAVE_FF(fp->fs, res);
?0562:
	LD	A,(IY+4)
	OR	A
	JP	M,?0996
?0563:
; 2452.	        if (fp->flag & FA__ERROR)                               /* Aborted file? */
; 2453.	                LEAVE_FF(fp->fs, FR_INT_ERR);
?0564:
	BIT	1,(IY+4)
	JR	NZ,?0566
?0565:
; 2454.	        if (!(fp->flag & FA_WRITE))                             /* Check access mode */
	LD	A,7
; 2455.	                LEAVE_FF(fp->fs, FR_DENIED);
	JP	?0612
?0566:
	LD	L,(IY+12)
	LD	H,(IY+13)
	PUSH	HL
	LD	L,(IY+10)
	LD	H,(IY+11)
	PUSH	HL
	LD	L,(IX+8)
	LD	H,(IX+9)
	LD	DE,0
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	POP	BC
	ADC	HL,BC
	EX	DE,HL
	AND	A
	LD	C,(IY+10)
	LD	B,(IY+11)
	SBC	HL,BC
	EX	DE,HL
	LD	C,(IY+12)
	LD	B,(IY+13)
	SBC	HL,BC
	JR	NC,?0568
?0567:
	XOR	A
	LD	(IX+8),A
	LD	(IX+9),A
?0568:
?0570:
; 2456.	        if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;      /* File size cannot reach 4GB */
; 2457.	
	LD	A,(IX+8)
	OR	(IX+9)
	JP	Z,?0569
?0571:
; 2459.	                wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
	LD	L,(IY+6)
	LD	A,(IY+7)
	AND	1
	LD	H,A
	LD	A,L
	OR	H
	JP	NZ,?0574
?0573:
; 2460.	                if ((fp->fptr % SS(fp->fs)) == 0) {     /* On the sector boundary? */
	LD	C,(IY+8)
	LD	B,(IY+9)
	LD	L,(IY+6)
	LD	H,(IY+7)
	LD	A,9
	CALL	?UL_RSH_L03
	PUSH	HL
	LD	L,(IY+0)
	LD	H,(IY+1)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	ADD	A,255
	POP	HL
	AND	L
	LD	(IX-2),A
; 2461.	                        csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));    /* Sector offset in the cluster */
	JR	NZ,?0576
?0575:
; 2462.	                        if (!csect) {                                   /* On the cluster boundary? */
	LD	A,(IY+6)
	OR	(IY+7)
	OR	(IY+8)
	OR	(IY+9)
	JR	NZ,?0578
?0577:
; 2463.	                                if (fp->fptr == 0) {            /* On the top of the file? */
	LD	C,(IY+16)
	LD	B,(IY+17)
	LD	L,(IY+14)
	LD	H,(IY+15)
; 2464.	                                        clst = fp->sclust;              /* Follow from the origin */
	LD	A,L
	OR	H
	OR	C
	OR	B
	JR	NZ,?0581
?0579:
; 2465.	                                        if (clst == 0)                  /* When no cluster is allocated, */
	LD	L,A
	LD	H,A
	PUSH	HL
	PUSH	HL
	CALL	?1053
	POP	AF
	POP	AF
	LD	(IY+14),L
	LD	(IY+15),H
	LD	(IY+16),C
	LD	(IY+17),B
?0580:
; 2466.	                                                fp->sclust = clst = create_chain(fp->fs, 0);    /* Create a new cluster chain */
	JR	?0581
?0578:
; 2467.	                                } else {                                        /* Middle or end of the file */
; 2468.	#if _USE_FASTSEEK
; 2472.	#endif
	LD	L,(IY+20)
	LD	H,(IY+21)
	PUSH	HL
	LD	L,(IY+18)
	LD	H,(IY+19)
	PUSH	HL
	CALL	?1053
	POP	AF
	POP	AF
?0581:
; 2473.	                                                clst = create_chain(fp->fs, fp->clust); /* Follow or stretch cluster chain on the FAT */
; 2474.	                                }
	LD	A,L
	OR	H
	OR	C
	OR	B
	JP	Z,?0569
?0582:
?0583:
; 2475.	                                if (clst == 0) break;           /* Could not allocate a new cluster (disk full) */
	LD	A,1
	XOR	L
	OR	H
	OR	C
	OR	B
	JR	Z,?1000
?0584:
?0585:
; 2476.	                                if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
	LD	A,L
	AND	H
	AND	C
	AND	B
	INC	A
	JR	Z,?0997
?0586:
?0587:
; 2477.	                                if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
	LD	(IY+18),L
	LD	(IY+19),H
	LD	(IY+20),C
	LD	(IY+21),B
?0576:
; 2478.	                                fp->clust = clst;                       /* Update current cluster */
; 2479.	                        }
; 2480.	#if _FS_TINY
; 2483.	#else
	BIT	6,(IY+4)
	JR	Z,?0589
?0588:
; 2484.	                        if (fp->flag & FA__DIRTY) {             /* Write-back sector cache */
; 2485.	                                SET_DIO_PAR(fp->fs->drv, fp->buf, fp->dsect, 1);
	CALL	?1038
	OR	A
	JR	Z,?0591
?0590:
; 2486.	                                if (disk_write() != RES_OK)
?0997:
	JP	?0999
?0591:
; 2487.	                                        ABORT(fp->fs, FR_DISK_ERR);
	RES	6,(IY+4)
?0589:
; 2488.	                                fp->flag &= ~FA__DIRTY;
; 2489.	                        }
; 2490.	#endif
	LD	L,(IY+20)
	LD	H,(IY+21)
	PUSH	HL
	LD	L,(IY+18)
	LD	H,(IY+19)
	PUSH	HL
	CALL	?1052
	POP	AF
	POP	AF
	LD	(IX-12),L
	LD	(IX-11),H
	LD	(IX-10),C
	LD	(IX-9),B
; 2491.	                        sect = clust2sect(fp->fs, fp->clust);   /* Get current sector */
	LD	A,L
	OR	H
	OR	C
	OR	B
	JR	NZ,?0593
?0592:
?1000:
	SET	7,(IY+4)
?0996:
	LD	A,2
	JP	?0612
?0593:
; 2492.	                        if (!sect) ABORT(fp->fs, FR_INT_ERR);
	LD	HL,6
	ADD	HL,SP
	CALL	?1040
; 2493.	                        sect += csect;
	PUSH	DE
	EXX
	POP	DE
	EXX
; 2494.	                        cc = btw / SS(fp->fs);                  /* When remaining bytes >= sector size, */
	LD	A,E
	OR	D
	JP	Z,?0595
?0594:
; 2495.	                        if (cc) {                                               /* Write maximum contiguous sectors directly */
	LD	C,(IX-2)
	LD	B,0
	EXX
	PUSH	DE
	EXX
	POP	HL
	ADD	HL,BC
	LD	C,L
	LD	B,H
	LD	L,(IY+0)
	LD	H,(IY+1)
	INC	HL
	INC	HL
	INC	HL
	LD	L,(HL)
	LD	H,0
	AND	A
	SBC	HL,BC
	JR	NC,?0597
?0596:
; 2496.	                                if (csect + cc > fp->fs->csize) /* Clip at cluster boundary */
	LD	C,(IX-2)
	LD	B,0
	LD	L,(IY+0)
	LD	H,(IY+1)
	INC	HL
	INC	HL
	INC	HL
	LD	L,(HL)
	LD	H,B
	AND	A
	SBC	HL,BC
	PUSH	HL
	EXX
	POP	DE
	EXX
?0597:
; 2497.	                                        cc = fp->fs->csize - csect;
	LD	L,(IY+0)
	LD	H,(IY+1)
	INC	HL
	LD	A,(HL)
	LD	(dio_par),A
	LD	L,(IX-4)
	LD	H,(IX-3)
	LD	(dio_par+1),HL
	LD	HL,6
	ADD	HL,SP
	LD	(dio_par+3),HL
	EXX
	PUSH	DE
	EXX
	POP	HL
	LD	A,L
; 2498.	                                SET_DIO_PAR(fp->fs->drv, wbuff, sect, (BYTE)cc);
	CALL	?1039
	OR	A
	JP	NZ,?0999
?0598:
; 2499.	                                if (disk_write() != RES_OK)
?0599:
; 2500.	                                        ABORT(fp->fs, FR_DISK_ERR);
; 2501.	#if _FS_TINY
; 2506.	#else
	EXX
	PUSH	DE
	EXX
	POP	HL
	LD	C,A
	LD	B,A
	PUSH	BC
	PUSH	HL
	AND	A
	LD	L,(IY+22)
	LD	H,(IY+23)
	LD	C,(IX-12)
	LD	B,(IX-11)
	SBC	HL,BC
	EX	DE,HL
	LD	L,(IY+24)
	LD	H,(IY+25)
	LD	C,(IX-10)
	LD	B,(IX-9)
	SBC	HL,BC
	EX	DE,HL
	AND	A
	POP	BC
	SBC	HL,BC
	EX	DE,HL
	POP	BC
	SBC	HL,BC
	JR	NC,?0601
?0600:
; 2507.	                                if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
	LD	HL,32
	PUSH	IY
	POP	DE
	ADD	HL,DE
	EX	DE,HL
	LD	C,(IX-12)
	LD	B,(IX-11)
	LD	L,(IY+22)
	LD	H,(IY+23)
	AND	A
	SBC	HL,BC
	LD	H,L
	LD	L,A
	ADD	HL,HL
	LD	C,(IX-4)
	LD	B,(IX-3)
	ADD	HL,BC
	LD	BC,512
	LDIR
; 2508.	                                        memcpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
	RES	6,(IY+4)
?0601:
; 2509.	                                        fp->flag &= ~FA__DIRTY;
; 2510.	                                }
; 2511.	#endif
	EXX
	PUSH	DE
	EXX
	POP	HL
	LD	H,L
	LD	L,A
	ADD	HL,HL
	PUSH	HL
	EXX
	POP	BC
	EXX
; 2512.	                                wcnt = SS(fp->fs) * cc;         /* Number of bytes transferred */
	JP	?0572
?0595:
; 2513.	                                continue;
; 2514.	                        }
; 2515.	#if _FS_TINY
; 2520.	#else
	LD	L,(IY+22)
	LD	H,(IY+23)
	LD	C,(IX-12)
	LD	B,(IX-11)
	SBC	HL,BC
	JR	NZ,?0993
	LD	L,(IY+24)
	LD	H,(IY+25)
	LD	C,(IX-10)
	LD	B,(IX-9)
	SBC	HL,BC
	JR	Z,?0605
?0993:
?0602:
; 2521.	                        if (fp->dsect != sect) {                /* Fill sector cache with file data */
; 2522.	                                
	LD	L,(IY+0)
	LD	H,(IY+1)
	INC	HL
	LD	A,(HL)
	LD	(dio_par),A
	LD	HL,32
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	(dio_par+1),HL
	LD	HL,6
	ADD	HL,SP
	LD	(dio_par+3),HL
	LD	A,1
	LD	(dio_par+5),A
; 2523.	                                SET_DIO_PAR(fp->fs->drv, fp->buf, sect, 1);
; 2524.	                                if (fp->fptr < fp->fsize &&
	LD	HL,10
	ADD	HL,BC
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	PUSH	BC
	PUSH	DE
	AND	A
	LD	L,(IY+6)
	LD	H,(IY+7)
	POP	BC
	SBC	HL,BC
	LD	L,(IY+8)
	LD	H,(IY+9)
	POP	BC
	SBC	HL,BC
	JR	NC,?0605
	CALL	?1043
	JR	Z,?0605
?0607:
?0606:
?0604:
; 2525.	                                        disk_read() != RES_OK)
?0999:
	SET	7,(IY+4)
	LD	A,1
	JP	?0612
?0605:
?0603:
; 2526.	                                                ABORT(fp->fs, FR_DISK_ERR);
; 2527.	                        }
; 2528.	#endif
	LD	C,(IX-10)
	LD	B,(IX-9)
	LD	L,(IX-12)
	LD	(IY+22),L
	LD	H,(IX-11)
	LD	(IY+23),H
	LD	(IY+24),C
	LD	(IY+25),B
?0574:
; 2529.	                        fp->dsect = sect;
; 2530.	                }
	LD	C,(IY+6)
	LD	A,(IY+7)
	AND	1
	LD	B,A
	LD	HL,512
	SBC	HL,BC
	PUSH	HL
	EXX
	POP	BC
	EXX
; 2531.	                wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
	LD	C,L
	LD	B,H
	LD	L,(IX+8)
	LD	H,(IX+9)
	AND	A
	SBC	HL,BC
	JR	NC,?0609
?0608:
	EXX
	LD	C,(IX+8)
	LD	B,(IX+9)
	EXX
?0609:
; 2532.	                if (wcnt > btw) wcnt = btw;
; 2533.	#if _FS_TINY
; 2538.	#else
	EXX
	PUSH	BC
	EXX
	POP	BC
	LD	L,(IY+6)
	LD	A,(IY+7)
	AND	1
	LD	H,A
	PUSH	IY
	POP	DE
	ADD	HL,DE
	LD	DE,32
	ADD	HL,DE
	EX	DE,HL
	LD	L,(IX-4)
	LD	H,(IX-3)
	LD	A,C
	OR	B
	JR	Z,?0994
	LDIR
?0994:
; 2539.	                memcpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);   /* Fit partial sector */
	SET	6,(IY+4)
?0572:
; 2458.	        for ( ;  btw;                                                   /* Repeat until all data written */
	LD	HL,14
	ADD	HL,SP
	EXX
	PUSH	BC
	EXX
	POP	BC
	LD	A,(HL)
	ADD	A,C
	LD	(HL),A
	INC	HL
	LD	A,(HL)
	ADC	A,B
	LD	(HL),A
	LD	HL,6
	PUSH	IY
	POP	BC
	ADD	HL,BC
	EXX
	PUSH	BC
	EXX
	POP	DE
	LD	BC,0
	CALL	?L_ADDASG_L03
	EXX
	PUSH	BC
	EXX
	POP	BC
	LD	L,(IX+10)
	LD	H,(IX+11)
	LD	A,(HL)
	ADD	A,C
	LD	(HL),A
	INC	HL
	LD	A,(HL)
	ADC	A,B
	LD	(HL),A
	LD	HL,26
	ADD	HL,SP
	LD	A,(HL)
	SUB	C
	LD	(HL),A
	INC	HL
	LD	A,(HL)
	SBC	A,B
	LD	(HL),A
; 2540.	                fp->flag |= FA__DIRTY;
; 2541.	#endif
; 2542.	        }
; 2543.	
	JP	?0568
?0569:
	LD	L,(IY+10)
	LD	H,(IY+11)
	LD	C,(IY+6)
	LD	B,(IY+7)
	SBC	HL,BC
	LD	L,(IY+12)
	LD	H,(IY+13)
	LD	C,(IY+8)
	LD	B,(IY+9)
	SBC	HL,BC
	JR	NC,?0611
?0610:
	LD	C,(IY+8)
	LD	B,(IY+9)
	LD	L,(IY+6)
	LD	H,(IY+7)
	LD	(IY+10),L
	LD	(IY+11),H
	LD	(IY+12),C
	LD	(IY+13),B
?0611:
; 2544.	        if (fp->fptr > fp->fsize) fp->fsize = fp->fptr; /* Update file size if needed */
	SET	5,(IY+4)
; 2545.	        fp->flag |= FA__WRITTEN;                                                /* Set file change flag */
; 2546.	
; 2547.	        LEAVE_FF(fp->fs, FR_OK);
?0612:
	JP	?0154
; 2548.	}
; 2549.	
; 2550.	
; 2551.	
; 2552.	
; 2553.	/*-----------------------------------------------------------------------*/
; 2554.	/* Synchronize the File Object                                           */
; 2555.	/*-----------------------------------------------------------------------*/
; 2556.	
; 2557.	FRESULT f_sync (
; 2558.	        FIL *fp         /* Pointer to the file object */
; 2559.	)
f_sync:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	-6
	PUSH	IY
; 2560.	{
; 2561.	        FRESULT res;
; 2562.	        DWORD tim;
; 2563.	        BYTE *dir;
; 2564.	
; 2565.	
	CALL	?1065
; 2566.	        res = validate(fp->fs, fp->id);         /* Check validity of the object */
	OR	A
	JP	NZ,?0622
?0613:
; 2567.	        if (res == FR_OK) {
	BIT	5,(IY+4)
	JP	Z,?0622
?0615:
; 2568.	                if (fp->flag & FA__WRITTEN) {   /* Has the file been written? */
; 2569.	#if !_FS_TINY   /* Write-back dirty buffer */
	BIT	6,(IY+4)
	JR	Z,?0618
?0617:
; 2570.	                        if (fp->flag & FA__DIRTY) {
; 2571.	                                SET_DIO_PAR(fp->fs->drv, fp->buf, fp->dsect, 1);
	CALL	?1038
	OR	A
	JR	Z,?0620
?0619:
; 2572.	                                if (disk_write() != RES_OK)
	LD	A,1
; 2573.	                                        LEAVE_FF(fp->fs, FR_DISK_ERR);
	JP	?0622
?0620:
	RES	6,(IY+4)
?0618:
; 2574.	                                fp->flag &= ~FA__DIRTY;
; 2575.	                        }
; 2576.	#endif
; 2577.	                        /* Update the directory entry */
	LD	L,(IY+28)
	LD	H,(IY+29)
	PUSH	HL
	LD	L,(IY+26)
	LD	H,(IY+27)
	PUSH	HL
	LD	E,(IY+0)
	LD	D,(IY+1)
	CALL	move_window
	POP	HL
	POP	HL
; 2578.	                        res = move_window(fp->fs, fp->dir_sect);
	OR	A
	JR	NZ,?0622
?0621:
; 2579.	                        if (res == FR_OK) {
	LD	E,(IY+30)
	LD	D,(IY+31)
; 2580.	                                dir = fp->dir_ptr;
	LD	HL,11
	ADD	HL,DE
	SET	5,(HL)
; 2581.	                                dir[DIR_Attr] |= AM_ARC;                                        /* Set archive bit */
	PUSH	DE
	LD	C,(IY+12)
	LD	B,(IY+13)
	LD	L,(IY+10)
	LD	H,(IY+11)
	PUSH	HL
	LD	HL,28
	ADD	HL,DE
	POP	DE
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	LD	(HL),C
	INC	HL
	LD	(HL),B
	POP	DE
; 2582.	                                ST_DWORD(dir+DIR_FileSize, fp->fsize);          /* Update file size */
	LD	HL,26
	ADD	HL,DE
	LD	C,(IY+14)
	LD	(HL),C
	LD	B,(IY+15)
	INC	HL
	LD	(HL),B
	PUSH	DE
	LD	HL,20
	ADD	HL,DE
	PUSH	HL
	LD	L,(IY+16)
	LD	H,(IY+17)
	EX	DE,HL
	POP	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
; 2583.	                                ST_CLUST(dir, fp->sclust);                                      /* Update start cluster */
	LD	HL,6
	ADD	HL,SP
	EX	DE,HL
	CALL	get_fattime
	POP	DE
; 2584.	                                get_fattime(&tim);                                              /* Update updated time */
	LD	HL,22
	ADD	HL,DE
	LD	C,(IX-2)
	LD	B,(IX-1)
	LD	E,(IX-4)
	LD	(HL),E
	LD	D,(IX-3)
	INC	HL
	LD	(HL),D
	INC	HL
	LD	(HL),C
	INC	HL
	LD	(HL),B
; 2585.	                                ST_DWORD(dir+DIR_WrtTime, tim);
	RES	5,(IY+4)
; 2586.	                                fp->flag &= ~FA__WRITTEN;
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	BC,5
	ADD	HL,BC
	LD	(HL),1
; 2587.	                                fp->fs->wflag = 1;
	LD	E,(IY+0)
	LD	D,(IY+1)
	CALL	sync
?0622:
?0616:
?0614:
; 2588.	                                res = sync(fp->fs);
; 2589.	                        }
; 2590.	                }
; 2591.	        }
; 2592.	
; 2593.	        LEAVE_FF(fp->fs, res);
?0623:
	POP	IY
	JP	?LEAVE_DIRECT_L09
; 2594.	}
; 2595.	
; 2596.	#endif /* !_FS_READONLY */
; 2597.	
; 2598.	
; 2599.	
; 2600.	
; 2601.	/*-----------------------------------------------------------------------*/
; 2602.	/* Close File                                                            */
; 2603.	/*-----------------------------------------------------------------------*/
; 2604.	
; 2605.	FRESULT f_close (
; 2606.	        FIL *fp         /* Pointer to the file object to be closed */
; 2607.	)
f_close:
	PUSH	IX
	PUSH	AF
	PUSH	DE
	POP	IX
; 2608.	{
; 2609.	        FRESULT res;
; 2610.	
; 2611.	#if _FS_READONLY
; 2617.	#else
	CALL	f_sync
	LD	HL,0
	ADD	HL,SP
	LD	(HL),A
; 2618.	        res = f_sync(fp);               /* Flush cached data */
; 2619.	#if _FS_SHARE
; 2621.	#if _FS_REENTRANT
; 2627.	#else
; 2629.	#endif
; 2631.	#endif
	XOR	A
	OR	(HL)
	JR	NZ,?0625
?0624:
	PUSH	IX
	POP	HL
	LD	(HL),A
	INC	HL
	LD	(HL),A
?0625:
; 2632.	        if (res == FR_OK) fp->fs = 0;   /* Discard file object */
; 2633.	        return res;
; 2634.	#endif
	POP	HL
	POP	IX
	RET
; 2635.	}
; 2636.	
; 2637.	
; 2638.	
; 2639.	
; 2640.	/*-----------------------------------------------------------------------*/
; 2641.	/* Current Drive/Directory Handlings                                     */
; 2642.	/*-----------------------------------------------------------------------*/
; 2643.	
; 2644.	#if _FS_RPATH >= 1
; 2645.	
; 2646.	FRESULT f_chdrive (
; 2647.	        BYTE drv                /* Drive number */
; 2648.	)
f_chdrive:
	PUSH	BC
	PUSH	DE
; 2649.	{
	LD	A,E
	CP	2
	JR	C,?0627
?0626:
	LD	A,11
; 2650.	        if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
; 2651.	
	JR	?0628
?0627:
	LD	A,E
	LD	(CurrVol),A
; 2652.	        CurrVol = drv;
; 2653.	
	XOR	A
; 2654.	        return FR_OK;
?0628:
	POP	HL
	POP	BC
	RET
; 2655.	}
; 2656.	
; 2657.	
; 2658.	
; 2659.	FRESULT f_chdir (
; 2660.	        const TCHAR *path       /* Pointer to the directory path */
; 2661.	)
f_chdir:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	-34
	PUSH	IY
; 2662.	{
; 2663.	        FRESULT res;
; 2664.	        DIR dj;
; 2665.	        DEF_NAMEBUF;
; 2666.	
; 2667.	
	LD	C,0
	PUSH	BC
	LD	HL,4
	ADD	HL,SP
	LD	C,L
	LD	B,H
	LD	HL,40
	ADD	HL,SP
	CALL	?1060
	POP	HL
	LD	IYL,A
; 2668.	        res = chk_mounted(&path, &dj.fs, 0);
	OR	A
	JR	NZ,?0640
?0629:
; 2669.	        if (res == FR_OK) {
	LD	HL,24
	ADD	HL,SP
	LD	(IX-14),L
	LD	(IX-13),H
; 2670.	                INIT_BUF(dj);
	LD	C,(IX+2)
	LD	B,(IX+3)
	LD	HL,2
	ADD	HL,SP
	CALL	?1062
; 2671.	                res = follow_path(&dj, path);           /* Follow the path */
; 2672.	                FREE_BUF();
	JR	NZ,?0638
?0631:
; 2673.	                if (res == FR_OK) {                                     /* Follow completed */
	LD	L,(IX-16)
	LD	A,L
	LD	H,(IX-15)
	OR	H
	JR	NZ,?0634
?0633:
; 2674.	                        if (!dj.dir) {
	LD	HL,23
	LD	C,(IX-34)
	LD	B,(IX-33)
	ADD	HL,BC
	PUSH	HL
	LD	HL,10
	ADD	HL,SP
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	POP	HL
	JR	?1001
; 2675.	                                dj.fs->cdir = dj.sclust;        /* Start directory itself */
?0634:
; 2676.	                        } else {
	LD	BC,11
	ADD	HL,BC
	BIT	4,(HL)
	JR	Z,?0637
?0636:
; 2677.	                                if (dj.dir[DIR_Attr] & AM_DIR)  /* Reached to the directory */
	LD	E,(IX-16)
	LD	D,(IX-15)
	CALL	LD_CLUST
	PUSH	HL
	LD	HL,23
	LD	E,(IX-34)
	LD	D,(IX-33)
	ADD	HL,DE
	POP	DE
?1001:
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	LD	(HL),C
	INC	HL
	LD	(HL),B
; 2678.	                                        dj.fs->cdir = LD_CLUST(dj.dir);
	JR	?0638
?0637:
; 2679.	                                else
	LD	IYL,5
?0638:
?0635:
?0632:
; 2680.	                                        res = FR_NO_PATH;               /* Reached but a file */
; 2681.	                        }
; 2682.	                }
	LD	A,IYL
	CP	4
	JR	NZ,?0640
?0639:
	LD	IYL,5
?0640:
?0630:
; 2683.	                if (res == FR_NO_FILE) res = FR_NO_PATH;
; 2684.	        }
; 2685.	
	LD	A,IYL
; 2686.	        LEAVE_FF(dj.fs, res);
	POP	IY
	JP	?LEAVE_DIRECT_L09
?1062:
	EX	DE,HL
?1063:
	CALL	follow_path
	LD	IYL,A
	OR	A
	RET
; 2687.	}
; 2688.	
; 2689.	
; 2690.	#if _FS_RPATH >= 2
; 2727.	#if _USE_LFN
; 2730.	#endif
; 2759.	#endif /* _FS_RPATH >= 2 */
; 2760.	#endif /* _FS_RPATH >= 1 */
; 2761.	
; 2762.	
; 2763.	
; 2764.	#if _FS_MINIMIZE <= 2
; 2765.	/*-----------------------------------------------------------------------*/
; 2766.	/* Seek File R/W Pointer                                                 */
; 2767.	/*-----------------------------------------------------------------------*/
; 2768.	
; 2769.	FRESULT f_lseek (
; 2770.	        FIL *fp,                /* Pointer to the file object */
; 2771.	        DWORD ofs               /* File pointer from top of file */
; 2772.	)
f_lseek:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	65518
	PUSH	IY
; 2773.	{
; 2774.	        FRESULT res;
; 2775.	
; 2776.	
	CALL	?1065
	LD	(IX-18),A
; 2777.	        res = validate(fp->fs, fp->id);         /* Check validity of the object */
	OR	A
	JP	NZ,?0693
?0641:
; 2778.	        if (res != FR_OK) LEAVE_FF(fp->fs, res);
?0642:
	LD	A,(IY+4)
	OR	A
	JP	M,?1009
?0643:
; 2779.	        if (fp->flag & FA__ERROR)                       /* Check abort flag */
; 2780.	                LEAVE_FF(fp->fs, FR_INT_ERR);
; 2781.	
; 2782.	#if _USE_FASTSEEK
; 2821.	#if !_FS_TINY
; 2822.	#if !_FS_READONLY
; 2828.	#endif
; 2831.	#endif
; 2837.	#endif
; 2838.	
; 2839.	        /* Normal Seek */
?0644:
; 2840.	        {
; 2841.	                DWORD clst, bcs, nsect, ifptr;
; 2842.	
; 2843.	                if (ofs > fp->fsize                                     /* In read-only mode, clip offset with the file size */
; 2844.	#if !_FS_READONLY
; 2845.	                         && !(fp->flag & FA_WRITE)
; 2846.	#endif
	AND	A
	LD	L,(IY+10)
	LD	H,(IY+11)
	LD	C,(IX+8)
	LD	B,(IX+9)
	SBC	HL,BC
	LD	L,(IY+12)
	LD	H,(IY+13)
	LD	C,(IX+10)
	LD	B,(IX+11)
	SBC	HL,BC
	JR	NC,?0646
	BIT	1,(IY+4)
	JR	NZ,?0646
?0648:
?0647:
?0645:
	LD	C,(IY+12)
	LD	B,(IY+13)
	LD	L,(IY+10)
	LD	(IX+8),L
	LD	H,(IY+11)
	LD	(IX+9),H
	LD	(IX+10),C
	LD	(IX+11),B
?0646:
; 2847.	                        ) ofs = fp->fsize;
; 2848.	
	LD	C,(IY+8)
	LD	B,(IY+9)
	LD	L,(IY+6)
	LD	(IX-5),L
	LD	H,(IY+7)
	LD	(IX-4),H
	LD	(IX-3),C
	LD	(IX-2),B
; 2849.	                ifptr = fp->fptr;
	XOR	A
	LD	(IX-9),A
	LD	(IX-8),A
	LD	(IX-7),A
	LD	(IX-6),A
	LD	(IY+6),A
	LD	(IY+7),A
	LD	(IY+8),A
	LD	(IY+9),A
; 2850.	                fp->fptr = nsect = 0;
	LD	A,(IX+8)
	OR	(IX+9)
	OR	(IX+10)
	OR	(IX+11)
	JP	Z,?0679
?0649:
; 2851.	                if (ofs) {
	LD	L,(IY+0)
	LD	H,(IY+1)
	INC	HL
	INC	HL
	INC	HL
	LD	L,(HL)
	LD	BC,0
	LD	H,C
	LD	A,9
	CALL	?L_LSH_L03
	LD	(IX-13),L
	LD	(IX-12),H
	LD	(IX-11),C
	LD	(IX-10),B
; 2852.	                        bcs = (DWORD)fp->fs->csize * SS(fp->fs);        /* Cluster size (byte) */
; 2853.	                        if (ifptr > 0 &&
	LD	A,(IX-5)
	OR	(IX-4)
	OR	(IX-3)
	OR	(IX-2)
	JP	Z,?0652
	PUSH	BC
	PUSH	HL
	LD	HL,65535
	PUSH	HL
	PUSH	HL
	LD	L,(IX-5)
	LD	H,(IX-4)
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	LD	L,(IX-3)
	LD	H,(IX-2)
	POP	BC
	CALL	?1059
	PUSH	BC
	PUSH	HL
	LD	L,(IX-11)
	LD	H,(IX-10)
	PUSH	HL
	LD	L,(IX-13)
	LD	H,(IX-12)
	PUSH	HL
	LD	HL,65535
	PUSH	HL
	PUSH	HL
	LD	L,(IX+8)
	LD	H,(IX+9)
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	LD	L,(IX+10)
	LD	H,(IX+11)
	POP	BC
	CALL	?1059
	LD	E,C
	LD	D,B
	AND	A
	POP	BC
	SBC	HL,BC
	EX	DE,HL
	POP	BC
	SBC	HL,BC
	JR	C,?0652
?0654:
?0653:
?0651:
; 2854.	                                (ofs - 1) / bcs >= (ifptr - 1) / bcs) { /* When seek to same or following cluster, */
	LD	HL,65535
	PUSH	HL
	PUSH	HL
	LD	L,(IX-13)
	LD	H,(IX-12)
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	LD	L,(IX-11)
	LD	H,(IX-10)
	POP	BC
	ADC	HL,BC
	LD	C,L
	LD	B,H
	EX	DE,HL
	CALL	?L_NOT_L03
	PUSH	BC
	PUSH	HL
	LD	HL,65535
	PUSH	HL
	PUSH	HL
	LD	L,(IX-5)
	LD	H,(IX-4)
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	LD	L,(IX-3)
	LD	H,(IX-2)
	POP	BC
	ADC	HL,BC
	LD	C,L
	LD	B,H
	EX	DE,HL
	CALL	?L_AND_L03
	LD	(IY+6),L
	LD	(IY+7),H
	LD	(IY+8),C
	LD	(IY+9),B
; 2855.	                                fp->fptr = (ifptr - 1) & ~(bcs - 1);    /* start from the current cluster */
	LD	HL,28
	ADD	HL,SP
	LD	C,(IY+8)
	LD	B,(IY+9)
	LD	E,(IY+6)
	LD	D,(IY+7)
	CALL	?L_SUBASG_L03
; 2856.	                                ofs -= fp->fptr;
	LD	C,(IY+20)
	LD	B,(IY+21)
	LD	L,(IY+18)
	LD	(IX-17),L
	LD	H,(IY+19)
	LD	(IX-16),H
	LD	(IX-15),C
	LD	(IX-14),B
; 2857.	                                clst = fp->clust;
	JR	?0655
?0652:
; 2858.	                        } else {                                                                        /* When seek to back cluster, */
	LD	C,(IY+16)
	LD	B,(IY+17)
	LD	L,(IY+14)
	LD	(IX-17),L
	LD	H,(IY+15)
	LD	(IX-16),H
	LD	(IX-15),C
	LD	(IX-14),B
; 2859.	                                clst = fp->sclust;                                              /* start from the first cluster */
; 2860.	#if !_FS_READONLY
	LD	A,L
	OR	H
	OR	C
	OR	B
	JR	NZ,?0657
?0656:
; 2861.	                                if (clst == 0) {                                                /* If no cluster chain, create a new chain */
	LD	L,A
	LD	H,A
	PUSH	HL
	PUSH	HL
	CALL	?1053
	POP	AF
	POP	AF
	LD	(IX-17),L
	LD	(IX-16),H
	LD	(IX-15),C
	LD	(IX-14),B
; 2862.	                                        clst = create_chain(fp->fs, 0);
	LD	A,1
	XOR	L
	OR	H
	OR	C
	OR	B
	JP	Z,?1011
?0658:
?0659:
; 2863.	                                        if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
	LD	A,L
	AND	H
	AND	C
	AND	B
	INC	A
	JP	Z,?1010
?0660:
?0661:
; 2864.	                                        if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
	LD	(IY+14),L
	LD	(IY+15),H
	LD	(IY+16),C
	LD	(IY+17),B
?0657:
; 2865.	                                        fp->sclust = clst;
; 2866.	                                }
; 2867.	#endif
	LD	(IY+18),L
	LD	(IY+19),H
	LD	(IY+20),C
	LD	(IY+21),B
?0655:
; 2868.	                                fp->clust = clst;
; 2869.	                        }
	LD	A,L
	OR	H
	OR	C
	OR	B
	JP	Z,?0679
?0662:
?0665:
; 2870.	                        if (clst != 0) {
	AND	A
	LD	L,(IX-13)
	LD	H,(IX-12)
	LD	C,(IX+8)
	LD	B,(IX+9)
	SBC	HL,BC
	LD	L,(IX-11)
	LD	H,(IX-10)
	LD	C,(IX+10)
	LD	B,(IX+11)
	SBC	HL,BC
	JP	NC,?0664
?0666:
; 2871.	                                while (ofs > bcs) {                                             /* Cluster following loop */
; 2872.	#if !_FS_READONLY
	BIT	1,(IY+4)
	LD	L,(IX-15)
	LD	H,(IX-14)
	PUSH	HL
	LD	L,(IX-17)
	LD	H,(IX-16)
	PUSH	HL
	LD	E,(IY+0)
	LD	D,(IY+1)
	JR	Z,?0668
?0667:
; 2873.	                                        if (fp->flag & FA_WRITE) {                      /* Check if in write mode or not */
	CALL	create_chain
	POP	AF
	POP	AF
	LD	(IX-17),L
	LD	(IX-16),H
	LD	(IX-15),C
	LD	(IX-14),B
; 2874.	                                                clst = create_chain(fp->fs, clst);      /* Force stretch if in write mode */
	LD	A,L
	OR	H
	OR	C
	OR	B
	JR	NZ,?0671
?0669:
; 2875.	                                                if (clst == 0) {                                /* When disk gets full, clip file size */
	LD	C,(IX-11)
	LD	B,(IX-10)
	LD	L,(IX-13)
	LD	H,(IX-12)
	LD	(IX+8),L
	LD	(IX+9),H
	LD	(IX+10),C
	LD	(IX+11),B
	JP	?0664
?0670:
; 2876.	                                                        ofs = bcs; break;
; 2877.	                                                }
?0668:
; 2878.	                                        } else
; 2879.	#endif
	CALL	get_fat
	POP	AF
	POP	AF
	LD	(IX-17),L
	LD	(IX-16),H
	LD	(IX-15),C
	LD	(IX-14),B
?0671:
; 2880.	                                                clst = get_fat(fp->fs, clst);   /* Follow cluster chain if not in write mode */
	LD	A,L
	AND	H
	AND	C
	AND	B
	INC	A
	JP	Z,?1010
?0672:
?0673:
; 2881.	                                        if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
	LD	HL,1
	LD	C,(IX-17)
	LD	B,(IX-16)
	SBC	HL,BC
	LD	HL,0
	LD	C,(IX-15)
	LD	B,(IX-14)
	SBC	HL,BC
	JR	NC,?0676
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	BC,27
	ADD	HL,BC
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	PUSH	DE
	PUSH	BC
	AND	A
	LD	L,(IX-17)
	LD	H,(IX-16)
	POP	BC
	SBC	HL,BC
	LD	L,(IX-15)
	LD	H,(IX-14)
	POP	BC
	SBC	HL,BC
	JR	C,?0675
?0676:
?0677:
?0674:
	JP	?1011
?0675:
; 2882.	                                        if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
	LD	C,(IX-15)
	LD	B,(IX-14)
	LD	L,(IX-17)
	LD	(IY+18),L
	LD	H,(IX-16)
	LD	(IY+19),H
	LD	(IY+20),C
	LD	(IY+21),B
; 2883.	                                        fp->clust = clst;
	LD	HL,6
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	C,(IX-11)
	LD	B,(IX-10)
	LD	E,(IX-13)
	LD	D,(IX-12)
	CALL	?L_ADDASG_L03
; 2884.	                                        fp->fptr += bcs;
	LD	HL,28
	ADD	HL,SP
	LD	C,(IX-11)
	LD	B,(IX-10)
	LD	E,(IX-13)
	LD	D,(IX-12)
	CALL	?L_SUBASG_L03
; 2885.	                                        ofs -= bcs;
; 2886.	                                }
	JP	?0662
?0664:
	LD	HL,6
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	C,(IX+10)
	LD	B,(IX+11)
	LD	E,(IX+8)
	LD	D,(IX+9)
	CALL	?L_ADDASG_L03
; 2887.	                                fp->fptr += ofs;
	LD	L,(IX+8)
	LD	A,(IX+9)
	AND	1
	LD	H,A
	LD	A,L
	OR	H
	JR	Z,?0679
?0678:
; 2888.	                                if (ofs % SS(fp->fs)) {
	LD	L,(IX-15)
	LD	H,(IX-14)
	PUSH	HL
	LD	L,(IX-17)
	LD	H,(IX-16)
	PUSH	HL
	CALL	?1052
	POP	AF
	POP	AF
	LD	(IX-9),L
	LD	(IX-8),H
	LD	(IX-7),C
	LD	(IX-6),B
; 2889.	                                        nsect = clust2sect(fp->fs, clst);       /* Current sector */
	LD	A,L
	OR	H
	OR	C
	OR	B
	JR	NZ,?0681
?0680:
?1011:
	SET	7,(IY+4)
?1009:
	LD	A,2
	JP	?0694
?0681:
; 2890.	                                        if (!nsect) ABORT(fp->fs, FR_INT_ERR);
	LD	HL,11
	ADD	HL,SP
	PUSH	HL
	LD	A,9
	CALL	?1048
	EX	DE,HL
	POP	HL
	CALL	?L_ADDASG_L03
?0679:
?0663:
?0650:
; 2891.	                                        nsect += ofs / SS(fp->fs);
; 2892.	                                }
; 2893.	                        }
; 2894.	                }
	LD	L,(IY+6)
	LD	A,(IY+7)
	AND	1
	LD	H,A
	LD	A,L
	OR	H
	JR	Z,?0683
	LD	L,(IY+22)
	LD	H,(IY+23)
	LD	C,(IX-9)
	LD	B,(IX-8)
	SBC	HL,BC
	JR	NZ,?1003
	LD	L,(IY+24)
	LD	H,(IY+25)
	LD	C,(IX-7)
	LD	B,(IX-6)
	SBC	HL,BC
	JR	Z,?0683
?1003:
?0685:
?0684:
?0682:
; 2895.	                if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {      /* Fill sector cache if needed */
; 2896.	#if !_FS_TINY
; 2897.	#if !_FS_READONLY
	BIT	6,(IY+4)
	JR	Z,?0687
?0686:
; 2898.	                        if (fp->flag & FA__DIRTY) {                     /* Write-back dirty sector cache */
; 2899.	                                SET_DIO_PAR(fp->fs->drv, fp->buf, fp->dsect, 1);
	CALL	?1038
	OR	A
	JR	NZ,?1010
?0688:
; 2900.	                                if (disk_write() != RES_OK)
?0689:
; 2901.	                                        ABORT(fp->fs, FR_DISK_ERR);
	RES	6,(IY+4)
?0687:
; 2902.	                                fp->flag &= ~FA__DIRTY;
; 2903.	                        }
; 2904.	#endif
	LD	L,(IY+0)
	LD	H,(IY+1)
	INC	HL
	LD	A,(HL)
	LD	(dio_par),A
	LD	HL,32
	PUSH	IY
	POP	BC
	ADD	HL,BC
	LD	(dio_par+1),HL
	LD	HL,11
	ADD	HL,SP
; 2905.	                        SET_DIO_PAR(fp->fs->drv, fp->buf, nsect, 1);
	CALL	?1041
	JR	Z,?0691
?0690:
; 2906.	                        if (disk_read() != RES_OK)      /* Fill sector cache */
?1010:
	SET	7,(IY+4)
	LD	A,1
	JR	?0694
?0691:
; 2907.	                                ABORT(fp->fs, FR_DISK_ERR);
; 2908.	#endif
	LD	C,(IX-7)
	LD	B,(IX-6)
	LD	L,(IX-9)
	LD	(IY+22),L
	LD	H,(IX-8)
	LD	(IY+23),H
	LD	(IY+24),C
	LD	(IY+25),B
?0683:
; 2909.	                        fp->dsect = nsect;
; 2910.	                }
; 2911.	#if !_FS_READONLY
	AND	A
	LD	L,(IY+10)
	LD	H,(IY+11)
	LD	C,(IY+6)
	LD	B,(IY+7)
	SBC	HL,BC
	LD	L,(IY+12)
	LD	H,(IY+13)
	LD	C,(IY+8)
	LD	B,(IY+9)
	SBC	HL,BC
	JR	NC,?0693
?0692:
; 2912.	                if (fp->fptr > fp->fsize) {                     /* Set file change flag if the file size is extended */
	LD	C,(IY+8)
	LD	B,(IY+9)
	LD	L,(IY+6)
	LD	H,(IY+7)
	LD	(IY+10),L
	LD	(IY+11),H
	LD	(IY+12),C
	LD	(IY+13),B
; 2913.	                        fp->fsize = fp->fptr;
	SET	5,(IY+4)
?0693:
; 2914.	                        fp->flag |= FA__WRITTEN;
; 2915.	                }
; 2916.	#endif
; 2917.	        }
; 2918.	
	LD	A,(IX-18)
; 2919.	        LEAVE_FF(fp->fs, res);
?0694:
	POP	IY
	JP	?LEAVE_DIRECT_L09
; 2920.	}
; 2921.	
; 2922.	
; 2923.	
; 2924.	#if _FS_MINIMIZE <= 1
; 2925.	/*-----------------------------------------------------------------------*/
; 2926.	/* Create a Directroy Object                                             */
; 2927.	/*-----------------------------------------------------------------------*/
; 2928.	
; 2929.	FRESULT f_opendir (
; 2930.	        DIR *dj,                        /* Pointer to directory object to create */
; 2931.	        const TCHAR *path       /* Pointer to the directory path */
; 2932.	)
f_opendir:
	PUSH	IY
	PUSH	IX
	PUSH	BC
	LD	HL,65524
	ADD	HL,SP
	LD	SP,HL
	PUSH	DE
	POP	IX
; 2933.	{
; 2934.	        FRESULT res;
; 2935.	        DEF_NAMEBUF;
; 2936.	
; 2937.	
	LD	L,0
	PUSH	HL
	LD	C,E
	LD	B,D
	LD	HL,14
	ADD	HL,SP
	CALL	?1060
	POP	HL
	LD	IYL,A
; 2938.	        res = chk_mounted(&path, &dj->fs, 0);
	OR	A
	JR	NZ,?0707
?0695:
; 2939.	        if (res == FR_OK) {
	LD	L,A
	LD	H,A
	ADD	HL,SP
	LD	(IX+20),L
	LD	(IX+21),H
; 2940.	                INIT_BUF(*dj);
	LD	HL,12
	ADD	HL,SP
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	PUSH	IX
	POP	DE
	CALL	?1063
; 2941.	                res = follow_path(dj, path);                    /* Follow the path to the directory */
; 2942.	                FREE_BUF();
	JR	NZ,?0705
?0697:
; 2943.	                if (res == FR_OK) {                                             /* Follow completed */
	LD	A,(IX+18)
	OR	(IX+19)
	JR	Z,?0703
?0699:
; 2944.	                        if (dj->dir) {                                          /* It is not the root dir */
	LD	L,(IX+18)
	LD	H,(IX+19)
	LD	BC,11
	ADD	HL,BC
	BIT	4,(HL)
	JR	Z,?0702
?0701:
; 2945.	                                if (dj->dir[DIR_Attr] & AM_DIR) {       /* The object is a directory */
	LD	E,(IX+18)
	LD	D,(IX+19)
	CALL	LD_CLUST
	LD	(IX+6),L
	LD	(IX+7),H
	LD	(IX+8),C
	LD	(IX+9),B
; 2946.	                                        dj->sclust = LD_CLUST(dj->dir);
	JR	?0703
?0702:
; 2947.	                                } else {                                                /* The object is not a directory */
	LD	IYL,5
?0703:
?0700:
; 2948.	                                        res = FR_NO_PATH;
; 2949.	                                }
; 2950.	                        }
	LD	B,IYL
	INC	B
	DEC	B
	JR	NZ,?0705
?0704:
; 2951.	                        if (res == FR_OK) {
	LD	L,(IX+0)
	LD	H,(IX+1)
	LD	C,7
	ADD	HL,BC
	LD	B,(HL)
	LD	(IX+2),B
	INC	HL
	LD	H,(HL)
	LD	(IX+3),H
; 2952.	                                dj->id = dj->fs->id;
	LD	BC,0
	PUSH	IX
	POP	DE
	CALL	dir_sdi
	LD	IYL,A
?0705:
?0698:
; 2953.	                                res = dir_sdi(dj, 0);                   /* Rewind dir */
; 2954.	                        }
; 2955.	                }
	LD	A,IYL
	CP	4
	JR	NZ,?0707
?0706:
	LD	IYL,5
?0707:
?0696:
; 2956.	                if (res == FR_NO_FILE) res = FR_NO_PATH;
; 2957.	        }
; 2958.	
	LD	A,IYL
; 2959.	        LEAVE_FF(dj->fs, res);
	LD	HL,14
	ADD	HL,SP
	LD	SP,HL
	POP	IX
	POP	IY
	RET
; 2960.	}
; 2961.	
; 2962.	
; 2963.	
; 2964.	
; 2965.	/*-----------------------------------------------------------------------*/
; 2966.	/* Read Directory Entry in Sequense                                      */
; 2967.	/*-----------------------------------------------------------------------*/
; 2968.	
; 2969.	FRESULT f_readdir (
; 2970.	        DIR *dj,                        /* Pointer to the open directory object */
; 2971.	        FILINFO *fno            /* Pointer to file information to return */
; 2972.	)
f_readdir:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	65522
	PUSH	IY
; 2973.	{
; 2974.	        FRESULT res;
; 2975.	        DEF_NAMEBUF;
; 2976.	
; 2977.	
	CALL	?1065
; 2978.	        res = validate(dj->fs, dj->id);                 /* Check validity of the object */
	OR	A
	JR	NZ,?1013
?0708:
; 2979.	        if (res == FR_OK) {
	LD	A,(IX+4)
	OR	(IX+5)
	JR	NZ,?0711
?0710:
; 2980.	                if (!fno) {
	LD	C,A
	LD	B,A
	PUSH	IY
	POP	DE
	CALL	dir_sdi
	JR	?1013
; 2981.	                        res = dir_sdi(dj, 0);                   /* Rewind the directory object */
?0711:
; 2982.	                } else {
	LD	HL,4
	ADD	HL,SP
	LD	(IY+20),L
	LD	(IY+21),H
; 2983.	                        INIT_BUF(*dj);
	PUSH	IY
	POP	DE
	CALL	dir_read
	LD	(IX-14),A
; 2984.	                        res = dir_read(dj);                             /* Read an directory item */
	CP	4
	JR	NZ,?0714
?0713:
; 2985.	                        if (res == FR_NO_FILE) {                /* Reached end of dir */
	XOR	A
	LD	(IY+14),A
	LD	(IY+15),A
	LD	(IY+16),A
	LD	(IY+17),A
; 2986.	                                dj->sect = 0;
	LD	(IX-14),A
?0714:
; 2987.	                                res = FR_OK;
; 2988.	                        }
	XOR	A
	OR	(IX-14)
	JR	NZ,?1013
?0715:
; 2989.	                        if (res == FR_OK) {                             /* A valid entry is found */
	LD	C,(IX+4)
	LD	B,(IX+5)
	PUSH	IY
	POP	DE
	CALL	get_fileinfo
; 2990.	                                get_fileinfo(dj, fno);          /* Get the object information */
	LD	BC,0
	PUSH	IY
	POP	DE
	CALL	dir_next
; 2991.	                                res = dir_next(dj, 0);          /* Increment index for next */
	CP	4
	JR	NZ,?1013
?0717:
; 2992.	                                if (res == FR_NO_FILE) {
	XOR	A
	LD	(IY+14),A
	LD	(IY+15),A
	LD	(IY+16),A
	LD	(IY+17),A
; 2993.	                                        dj->sect = 0;
?1013:
?0718:
?0716:
?0712:
?0709:
; 2994.	                                        res = FR_OK;
; 2995.	                                }
; 2996.	                        }
; 2997.	                        FREE_BUF();
; 2998.	                }
; 2999.	        }
; 3000.	
; 3001.	        LEAVE_FF(dj->fs, res);
	POP	IY
	JP	?LEAVE_DIRECT_L09
; 3002.	}
; 3003.	
; 3004.	
; 3005.	
; 3006.	#if _FS_MINIMIZE == 0
; 3007.	/*-----------------------------------------------------------------------*/
; 3008.	/* Get File Status                                                       */
; 3009.	/*-----------------------------------------------------------------------*/
; 3010.	
; 3011.	FRESULT f_stat (
; 3012.	        const TCHAR *path,      /* Pointer to the file path */
; 3013.	        FILINFO *fno            /* Pointer to file information to return */
; 3014.	)
f_stat:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	-34
	PUSH	IY
; 3015.	{
; 3016.	        FRESULT res;
; 3017.	        DIR dj;
; 3018.	        DEF_NAMEBUF;
; 3019.	
; 3020.	
	LD	E,0
	PUSH	DE
	LD	HL,4
	ADD	HL,SP
	LD	C,L
	LD	B,H
	LD	HL,40
	ADD	HL,SP
	CALL	?1060
	POP	HL
	LD	IYL,A
; 3021.	        res = chk_mounted(&path, &dj.fs, 0);
	OR	A
	JR	NZ,?0725
?0719:
; 3022.	        if (res == FR_OK) {
	LD	HL,24
	ADD	HL,SP
	LD	(IX-14),L
	LD	(IX-13),H
; 3023.	                INIT_BUF(dj);
	LD	C,(IX+2)
	LD	B,(IX+3)
	LD	HL,2
	ADD	HL,SP
	CALL	?1062
; 3024.	                res = follow_path(&dj, path);   /* Follow the file path */
	JR	NZ,?0725
?0721:
; 3025.	                if (res == FR_OK) {                             /* Follow completed */
	LD	A,(IX-16)
	LD	H,(IX-15)
	OR	H
	JR	Z,?0724
?0723:
; 3026.	                        if (dj.dir)             /* Found an object */
	LD	C,(IX+4)
	LD	B,(IX+5)
	LD	HL,2
	ADD	HL,SP
	EX	DE,HL
	CALL	get_fileinfo
; 3027.	                                get_fileinfo(&dj, fno);
	JR	?0725
?0724:
; 3028.	                        else                    /* It is root dir */
	LD	IYL,6
?0725:
?0722:
?0720:
; 3029.	                                res = FR_INVALID_NAME;
; 3030.	                }
; 3031.	                FREE_BUF();
; 3032.	        }
; 3033.	
	LD	A,IYL
; 3034.	        LEAVE_FF(dj.fs, res);
	POP	IY
	JP	?LEAVE_DIRECT_L09
; 3035.	}
; 3036.	
; 3037.	
; 3038.	
; 3039.	#if !_FS_READONLY
; 3040.	/*-----------------------------------------------------------------------*/
; 3041.	/* Get Number of Free Clusters                                           */
; 3042.	/*-----------------------------------------------------------------------*/
; 3043.	
; 3044.	FRESULT f_getfree (
; 3045.	        const TCHAR *path,      /* Pointer to the logical drive number (root dir) */
; 3046.	        DWORD *nclst,           /* Pointer to the variable to return number of free clusters */
; 3047.	        FATFS **fatfs           /* Pointer to pointer to corresponding file system object to return */
; 3048.	)
f_getfree:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	-20
	PUSH	IY
	EXX
	PUSH	DE
	EXX
	LD	L,(IX+8)
	LD	H,(IX+9)
	PUSH	HL
	POP	IY
; 3049.	{
; 3050.	        FRESULT res;
; 3051.	        DWORD n, clst, sect, stat;
; 3052.	        UINT i;
; 3053.	        BYTE fat, *p;
; 3054.	
; 3055.	
; 3056.	        /* Get drive number */
	LD	E,0
	PUSH	DE
	PUSH	IY
	POP	BC
	LD	HL,28
	ADD	HL,SP
	CALL	?1060
	POP	HL
	LD	(IX-2),A
; 3057.	        res = chk_mounted(&path, fatfs, 0);
	OR	A
	JP	NZ,?0730
?0726:
; 3058.	        if (res == FR_OK) {
; 3059.	                /* If free_clust is valid, return it without full cluster scan */
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	BC,15
	ADD	HL,BC
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	PUSH	DE
	PUSH	BC
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	BC,27
	ADD	HL,BC
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	PUSH	DE
	PUSH	BC
	LD	HL,65534
	POP	BC
	ADD	HL,BC
	EX	DE,HL
	LD	HL,65535
	POP	BC
	ADC	HL,BC
	EX	DE,HL
	AND	A
	POP	BC
	SBC	HL,BC
	EX	DE,HL
	POP	BC
	SBC	HL,BC
	LD	L,(IY+0)
	LD	H,(IY+1)
	JR	C,?0729
?0728:
; 3060.	                if ((*fatfs)->free_clust <= (*fatfs)->n_fatent - 2) {
	LD	BC,15
	ADD	HL,BC
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	JP	?1016
; 3061.	                        *nclst = (*fatfs)->free_clust;
?0729:
; 3062.	                } else {
; 3063.	                        /* Get number of free clusters */
	LD	B,(HL)
	LD	(IX-1),B
; 3064.	                        fat = (*fatfs)->fs_type;
	LD	(IX-20),A
	LD	(IX-19),A
	LD	(IX-18),A
	LD	(IX-17),A
; 3065.	                        n = 0;
	DEC	B
	JR	NZ,?0732
?0731:
; 3066.	                        if (fat == FS_FAT12) {
	LD	(IX-14),2
	LD	(IX-13),A
	LD	(IX-12),A
	LD	(IX-11),A
?0735:
; 3067.	                                clst = 2;
; 3068.	                                do {
	LD	L,(IX-12)
	LD	H,(IX-11)
	PUSH	HL
	LD	L,(IX-14)
	LD	H,(IX-13)
	PUSH	HL
	CALL	?1049
	POP	AF
	POP	AF
; 3069.	                                        stat = get_fat(*fatfs, clst);
	LD	A,L
	AND	H
	AND	C
	AND	B
	INC	A
	JR	NZ,?0737
?0736:
	LD	(IX-2),1
	JR	?0733
?0737:
; 3070.	                                        if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
	LD	A,1
	XOR	L
	OR	H
	OR	C
	OR	B
	JR	NZ,?0739
?0738:
	LD	(IX-2),2
	JR	?0733
?0739:
; 3071.	                                        if (stat == 1) { res = FR_INT_ERR; break; }
	LD	A,L
	OR	H
	OR	C
	OR	B
	JR	NZ,?0741
?0740:
	CALL	?1051
?0741:
; 3072.	                                        if (stat == 0) n++;
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	BC,27
	ADD	HL,BC
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	PUSH	DE
	PUSH	BC
	CALL	?1050
	LD	E,C
	LD	D,B
	AND	A
	POP	BC
	SBC	HL,BC
	EX	DE,HL
	POP	BC
	SBC	HL,BC
	JR	C,?0735
?0733:
; 3073.	                                } while (++clst < (*fatfs)->n_fatent);
	JP	?0743
?0732:
; 3074.	                        } else {
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	BC,27
	ADD	HL,BC
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	EX	DE,HL
	LD	(IX-14),L
	LD	(IX-13),H
	LD	(IX-12),C
	LD	(IX-11),B
; 3075.	                                clst = (*fatfs)->n_fatent;
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	BC,35
	ADD	HL,BC
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	EX	DE,HL
	LD	(IX-6),L
	LD	(IX-5),H
	LD	(IX-4),C
	LD	(IX-3),B
; 3076.	                                sect = (*fatfs)->fatbase;
	LD	(IX-16),A
	LD	(IX-15),A
	EXX
	LD	DE,0
	EXX
?0745:
; 3077.	                                i = 0; p = 0;
; 3078.	                                do {
	EXX
	LD	A,E
	OR	D
	EXX
	JR	NZ,?0747
?0746:
; 3079.	                                        if (!i) {
	LD	L,(IX-6)
	LD	H,(IX-5)
	LD	C,(IX-4)
	LD	B,(IX-3)
	PUSH	BC
	PUSH	HL
	CALL	?L_INC_L03
	LD	(IX-6),L
	LD	(IX-5),H
	LD	(IX-4),C
	LD	(IX-3),B
	LD	E,(IY+0)
	LD	D,(IY+1)
	CALL	move_window
	POP	HL
	POP	HL
	LD	(IX-2),A
; 3080.	                                                res = move_window(*fatfs, sect++);
	OR	A
	JP	NZ,?0743
?0748:
?0749:
; 3081.	                                                if (res != FR_OK) break;
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	BC,51
	ADD	HL,BC
	LD	(IX-16),L
	LD	(IX-15),H
; 3082.	                                                p = (*fatfs)->win;
	EXX
	LD	DE,512
	EXX
?0747:
; 3083.	                                                i = SS(*fatfs);
; 3084.	                                        }
	LD	B,(IX-1)
	DEC	B
	DEC	B
	LD	L,(IX-16)
	LD	H,(IX-15)
	JR	NZ,?0751
?0750:
; 3085.	                                        if (fat == FS_FAT16) {
	LD	A,(HL)
	INC	HL
	OR	(HL)
	JR	NZ,?0753
?0752:
	CALL	?1051
?0753:
; 3086.	                                                if (LD_WORD(p) == 0) n++;
	LD	HL,8
	ADD	HL,SP
	LD	A,(HL)
	ADD	A,2
	LD	(HL),A
	INC	HL
	LD	A,(HL)
	ADC	A,0
	LD	(HL),A
	EXX
	LD	HL,65534
	JR	?1014
; 3087.	                                                p += 2; i -= 2;
?0751:
; 3088.	                                        } else {
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	A,(HL)
	EX	DE,HL
	AND	15
	LD	B,A
	LD	A,L
	OR	H
	OR	C
	OR	B
	JR	NZ,?0756
?0755:
	CALL	?1051
?0756:
; 3089.	                                                if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
	LD	HL,8
	ADD	HL,SP
	LD	A,(HL)
	ADD	A,4
	LD	(HL),A
	INC	HL
	LD	A,(HL)
	ADC	A,0
	LD	(HL),A
	EXX
	LD	HL,65532
?1014:
	ADD	HL,DE
	EX	DE,HL
	EXX
?0754:
; 3090.	                                                p += 4; i -= 4;
; 3091.	                                        }
	LD	L,(IX-14)
	LD	H,(IX-13)
	LD	C,(IX-12)
	LD	B,(IX-11)
	CALL	?L_DEC_L03
	LD	(IX-14),L
	LD	(IX-13),H
	LD	(IX-12),C
	LD	(IX-11),B
	LD	A,L
	OR	H
	OR	C
	OR	B
	JP	NZ,?0745
?0743:
?0742:
; 3092.	                                } while (--clst);
; 3093.	                        }
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	BC,15
	ADD	HL,BC
	LD	C,(IX-18)
	LD	B,(IX-17)
	LD	E,(IX-20)
	LD	(HL),E
	LD	D,(IX-19)
	INC	HL
	LD	(HL),D
	INC	HL
	LD	(HL),C
	INC	HL
	LD	(HL),B
; 3094.	                        (*fatfs)->free_clust = n;
	LD	A,(IX-1)
	CP	3
	JR	NZ,?0758
?0757:
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	BC,6
	ADD	HL,BC
	LD	(HL),1
?0758:
; 3095.	                        if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
	LD	C,(IX-18)
	LD	B,(IX-17)
?1016:
	EX	DE,HL
	PUSH	HL
	LD	L,(IX+4)
	LD	H,(IX+5)
	POP	DE
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	LD	(HL),C
	INC	HL
	LD	(HL),B
?0730:
?0727:
; 3096.	                        *nclst = n;
; 3097.	                }
; 3098.	        }
	JP	?0056
?1051:
	LD	L,(IX-20)
	LD	H,(IX-19)
	LD	C,(IX-18)
	LD	B,(IX-17)
	CALL	?L_INC_L03
	LD	(IX-20),L
	LD	(IX-19),H
	LD	(IX-18),C
	LD	(IX-17),B
	RET
; 3099.	        LEAVE_FF(*fatfs, res);
; 3100.	}
; 3101.	
; 3102.	
; 3103.	
; 3104.	
; 3105.	/*-----------------------------------------------------------------------*/
; 3106.	/* Truncate File                                                         */
; 3107.	/*-----------------------------------------------------------------------*/
; 3108.	
; 3109.	FRESULT f_truncate (
; 3110.	        FIL *fp         /* Pointer to the file object */
; 3111.	)
f_truncate:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	65530
	PUSH	IY
; 3112.	{
; 3113.	        FRESULT res;
; 3114.	        DWORD ncl;
; 3115.	
; 3116.	
	CALL	?1065
	LD	(IX-6),A
; 3117.	        res = validate(fp->fs, fp->id);         /* Check validity of the object */
	OR	A
	JR	NZ,?0765
?0759:
; 3118.	        if (res == FR_OK) {
	LD	A,(IY+4)
	OR	A
	JP	P,?0762
?0761:
; 3119.	                if (fp->flag & FA__ERROR) {                     /* Check abort flag */
	LD	(IX-6),2
; 3120.	                        res = FR_INT_ERR;
	JR	?0765
?0762:
; 3121.	                } else {
	BIT	1,(IY+4)
	JR	NZ,?0765
?0764:
; 3122.	                        if (!(fp->flag & FA_WRITE))             /* Check access mode */
	LD	(IX-6),7
?0765:
?0763:
?0760:
; 3123.	                                res = FR_DENIED;
; 3124.	                }
; 3125.	        }
	XOR	A
	OR	(IX-6)
	JP	NZ,?0784
?0766:
; 3126.	        if (res == FR_OK) {
	LD	L,(IY+6)
	LD	H,(IY+7)
	LD	C,(IY+10)
	LD	B,(IY+11)
	SBC	HL,BC
	LD	L,(IY+8)
	LD	H,(IY+9)
	LD	C,(IY+12)
	LD	B,(IY+13)
	SBC	HL,BC
	JP	NC,?0782
?0768:
; 3127.	                if (fp->fsize > fp->fptr) {
	LD	C,(IY+8)
	LD	B,(IY+9)
	LD	L,(IY+6)
	LD	H,(IY+7)
	LD	(IY+10),L
	LD	(IY+11),H
	LD	(IY+12),C
	LD	(IY+13),B
; 3128.	                        fp->fsize = fp->fptr;   /* Set file size to current R/W point */
	SET	5,(IY+4)
; 3129.	                        fp->flag |= FA__WRITTEN;
	LD	A,(IY+6)
	OR	(IY+7)
	OR	(IY+8)
	OR	(IY+9)
	JR	NZ,?0771
?0770:
; 3130.	                        if (fp->fptr == 0) {    /* When set file size to zero, remove entire cluster chain */
	LD	L,(IY+16)
	LD	H,(IY+17)
	PUSH	HL
	LD	L,(IY+14)
	LD	H,(IY+15)
	PUSH	HL
	LD	E,(IY+0)
	LD	D,(IY+1)
	CALL	remove_chain
	POP	HL
	POP	HL
	LD	(IX-6),A
; 3131.	                                res = remove_chain(fp->fs, fp->sclust);
	XOR	A
	LD	(IY+14),A
	LD	(IY+15),A
	LD	(IY+16),A
	LD	(IY+17),A
; 3132.	                                fp->sclust = 0;
	JP	?0782
?0771:
; 3133.	                        } else {                                /* When truncate a part of the file, remove remaining clusters */
	LD	L,(IY+20)
	LD	H,(IY+21)
	PUSH	HL
	LD	L,(IY+18)
	LD	H,(IY+19)
	PUSH	HL
	CALL	?1049
	POP	AF
	POP	AF
	LD	(IX-4),L
	LD	(IX-3),H
	LD	(IX-2),C
	LD	(IX-1),B
; 3134.	                                ncl = get_fat(fp->fs, fp->clust);
	LD	(IX-6),0
; 3135.	                                res = FR_OK;
	LD	A,L
	AND	H
	AND	C
	AND	B
	INC	A
	JR	NZ,?0774
?0773:
	LD	(IX-6),1
?0774:
; 3136.	                                if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
	LD	A,1
	XOR	L
	OR	H
	OR	C
	OR	B
	JR	NZ,?0776
?0775:
	LD	(IX-6),2
?0776:
; 3137.	                                if (ncl == 1) res = FR_INT_ERR;
	XOR	A
	OR	(IX-6)
	JR	NZ,?0782
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	BC,27
	ADD	HL,BC
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	PUSH	DE
	PUSH	BC
	AND	A
	LD	L,(IX-4)
	LD	H,(IX-3)
	POP	BC
	SBC	HL,BC
	LD	L,(IX-2)
	LD	H,(IX-1)
	POP	BC
	SBC	HL,BC
	JR	NC,?0782
?0780:
?0779:
?0777:
; 3138.	                                if (res == FR_OK && ncl < fp->fs->n_fatent) {
	LD	HL,4095
	PUSH	HL
	LD	H,L
	PUSH	HL
	LD	L,(IY+20)
	LD	H,(IY+21)
	PUSH	HL
	LD	L,(IY+18)
	LD	H,(IY+19)
	PUSH	HL
	LD	E,(IY+0)
	LD	D,(IY+1)
	CALL	put_fat
	POP	HL
	POP	HL
	POP	HL
	POP	HL
	LD	(IX-6),A
; 3139.	                                        res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
	OR	A
	JR	NZ,?0782
?0781:
	LD	L,(IX-2)
	LD	H,(IX-1)
	PUSH	HL
	LD	L,(IX-4)
	LD	H,(IX-3)
	PUSH	HL
	LD	E,(IY+0)
	LD	D,(IY+1)
	CALL	remove_chain
	POP	HL
	POP	HL
	LD	(IX-6),A
?0782:
?0778:
?0772:
?0769:
; 3140.	                                        if (res == FR_OK) res = remove_chain(fp->fs, ncl);
; 3141.	                                }
; 3142.	                        }
; 3143.	                }
	XOR	A
	OR	(IX-6)
	JR	Z,?0784
?0783:
	SET	7,(IY+4)
?0784:
?0767:
; 3144.	                if (res != FR_OK) fp->flag |= FA__ERROR;
; 3145.	        }
; 3146.	
; 3147.	        LEAVE_FF(fp->fs, res);
	POP	IY
	JP	?LEAVE_DIRECT_L09
; 3148.	}
; 3149.	
; 3150.	
; 3151.	
; 3152.	
; 3153.	/*-----------------------------------------------------------------------*/
; 3154.	/* Delete a File or Directory                                            */
; 3155.	/*-----------------------------------------------------------------------*/
; 3156.	
; 3157.	FRESULT f_unlink (
; 3158.	        const TCHAR *path               /* Pointer to the file or directory path */
; 3159.	)
f_unlink:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	-60
	PUSH	IY
	EXX
	PUSH	BC
	EXX
; 3160.	{
; 3161.	        FRESULT res;
; 3162.	        DIR dj, sdj;
; 3163.	        BYTE *dir;
; 3164.	        DWORD dclst;
; 3165.	        DEF_NAMEBUF;
; 3166.	
; 3167.	
	LD	C,1
	PUSH	BC
	LD	HL,10
	ADD	HL,SP
	LD	C,L
	LD	B,H
	LD	HL,68
	ADD	HL,SP
	CALL	?1060
	POP	HL
	LD	IYL,A
; 3168.	        res = chk_mounted(&path, &dj.fs, 1);
	OR	A
	JP	NZ,?0820
?0785:
; 3169.	        if (res == FR_OK) {
	LD	HL,52
	ADD	HL,SP
	LD	(IX-36),L
	LD	(IX-35),H
; 3170.	                INIT_BUF(dj);
	LD	C,(IX+2)
	LD	B,(IX+3)
	LD	HL,8
	ADD	HL,SP
	EX	DE,HL
	CALL	follow_path
	LD	IYL,A
	LD	B,IYL
; 3171.	                res = follow_path(&dj, path);           /* Follow the file path */
	INC	B
	DEC	B
	JR	NZ,?0788
	LD	L,(IX-36)
	LD	H,(IX-35)
	LD	C,11
	ADD	HL,BC
	BIT	5,(HL)
	JR	Z,?0788
?0790:
?0789:
?0787:
; 3172.	                if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
	LD	IYL,6
?0788:
; 3173.	                        res = FR_INVALID_NAME;                  /* Cannot remove dot entry */
; 3174.	#if _FS_SHARE
; 3176.	#endif
	LD	B,IYL
	INC	B
	DEC	B
	JP	NZ,?0820
?0791:
; 3177.	                if (res == FR_OK) {                                     /* The object is accessible */
	EXX
	LD	C,(IX-38)
	LD	A,C
	LD	B,(IX-37)
; 3178.	                        dir = dj.dir;
	OR	B
	EXX
	JR	NZ,?0794
?0793:
; 3179.	                        if (!dir) {
	LD	IYL,6
; 3180.	                                res = FR_INVALID_NAME;          /* Cannot remove the start directory */
	JR	?0797
?0794:
; 3181.	                        } else {
	LD	HL,11
	EXX
	PUSH	BC
	EXX
	POP	BC
	ADD	HL,BC
	BIT	0,(HL)
	JR	Z,?0797
?0796:
; 3182.	                                if (dir[DIR_Attr] & AM_RDO)
	LD	IYL,7
?0797:
?0795:
; 3183.	                                        res = FR_DENIED;                /* Cannot remove R/O object */
; 3184.	                        }
	EXX
	PUSH	BC
	EXX
	POP	DE
	CALL	LD_CLUST
	LD	(IX-60),L
	LD	(IX-59),H
	LD	(IX-58),C
	LD	(IX-57),B
; 3185.	                        dclst = LD_CLUST(dir);
	LD	B,IYL
	INC	B
	DEC	B
	JP	NZ,?0812
	LD	HL,11
	EXX
	PUSH	BC
	EXX
	POP	BC
	ADD	HL,BC
	BIT	4,(HL)
	JP	Z,?0812
?0801:
?0800:
?0798:
; 3186.	                        if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) { /* Is it a sub-dir? */
	AND	A
	LD	L,(IX-60)
	LD	H,(IX-59)
	LD	BC,2
	SBC	HL,BC
	LD	L,(IX-58)
	LD	H,(IX-57)
	DEC	BC
	DEC	BC
	SBC	HL,BC
	JR	NC,?0803
?0802:
; 3187.	                                if (dclst < 2) {
	LD	IYL,2
; 3188.	                                        res = FR_INT_ERR;
	JR	?0812
?0803:
; 3189.	                                } else {
	LD	C,22
	LD	HL,30
	ADD	HL,SP
	EX	DE,HL
	LD	HL,8
	ADD	HL,SP
	LDIR
; 3190.	                                        memcpy(&sdj, &dj, sizeof(DIR)); /* Check if the sub-dir is empty or not */
	LD	C,(IX-58)
	LD	B,(IX-57)
	LD	L,(IX-60)
	LD	H,(IX-59)
	LD	(IX-28),L
	LD	(IX-27),H
	LD	(IX-26),C
	LD	(IX-25),B
; 3191.	                                        sdj.sclust = dclst;
	LD	BC,2
	LD	HL,30
	ADD	HL,SP
	EX	DE,HL
	CALL	?1055
; 3192.	                                        res = dir_sdi(&sdj, 2);         /* Exclude dot entries */
	JR	NZ,?0812
?0805:
; 3193.	                                        if (res == FR_OK) {
	LD	HL,30
	ADD	HL,SP
	EX	DE,HL
	CALL	dir_read
	LD	IYL,A
; 3194.	                                                res = dir_read(&sdj);
; 3195.	                                                if (res == FR_OK                        /* Not empty dir */
; 3196.	#if _FS_RPATH
; 3197.	                                                || dclst == sdj.fs->cdir        /* Current dir */
; 3198.	#endif
	OR	A
	JR	Z,?0809
	LD	HL,23
	LD	C,(IX-34)
	LD	B,(IX-33)
	ADD	HL,BC
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	L,C
	LD	H,B
	LD	C,(IX-60)
	LD	B,(IX-59)
	AND	A
	SBC	HL,BC
	JR	NZ,?0808
	EX	DE,HL
	LD	C,(IX-58)
	LD	B,(IX-57)
	SBC	HL,BC
	JR	NZ,?0808
?0809:
?0810:
?0807:
	LD	IYL,7
?0808:
; 3199.	                                                ) res = FR_DENIED;
	LD	A,IYL
	CP	4
	JR	NZ,?0812
?0811:
	LD	IYL,0
?0812:
?0806:
?0804:
?0799:
; 3200.	                                                if (res == FR_NO_FILE) res = FR_OK;     /* Empty */
; 3201.	                                        }
; 3202.	                                }
; 3203.	                        }
	LD	B,IYL
	INC	B
	DEC	B
	JR	NZ,?0820
?0813:
; 3204.	                        if (res == FR_OK) {
	LD	HL,8
	ADD	HL,SP
	EX	DE,HL
	CALL	dir_remove
	LD	IYL,A
; 3205.	                                res = dir_remove(&dj);          /* Remove the directory entry */
	OR	A
	JR	NZ,?0820
?0815:
; 3206.	                                if (res == FR_OK) {
	LD	A,(IX-60)
	OR	(IX-59)
	OR	(IX-58)
	OR	(IX-57)
	JR	Z,?0818
?0817:
; 3207.	                                        if (dclst)                              /* Remove the cluster chain if exist */
	LD	L,(IX-58)
	LD	H,(IX-57)
	PUSH	HL
	LD	L,(IX-60)
	LD	H,(IX-59)
	PUSH	HL
	LD	E,(IX-56)
	LD	D,(IX-55)
	CALL	remove_chain
	POP	HL
	POP	HL
	LD	IYL,A
?0818:
; 3208.	                                                res = remove_chain(dj.fs, dclst);
	LD	B,IYL
	INC	B
	DEC	B
	JR	NZ,?0820
?0819:
	LD	E,(IX-56)
	LD	D,(IX-55)
	CALL	sync
	LD	IYL,A
?0820:
?0816:
?0814:
?0792:
?0786:
; 3209.	                                        if (res == FR_OK) res = sync(dj.fs);
; 3210.	                                }
; 3211.	                        }
; 3212.	                }
; 3213.	                FREE_BUF();
; 3214.	        }
	LD	A,IYL
; 3215.	        LEAVE_FF(dj.fs, res);
	JP	?0190
; 3216.	}
; 3217.	
; 3218.	
; 3219.	
; 3220.	
; 3221.	/*-----------------------------------------------------------------------*/
; 3222.	/* Create a Directory                                                    */
; 3223.	/*-----------------------------------------------------------------------*/
; 3224.	
; 3225.	FRESULT f_mkdir (
; 3226.	        const TCHAR *path               /* Pointer to the directory path */
; 3227.	)
f_mkdir:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	-52
	PUSH	IY
; 3228.	{
; 3229.	        FRESULT res;
; 3230.	        DIR dj;
; 3231.	        BYTE *dir, n;
; 3232.	        DWORD dsc, dcl, pcl, tim;
; 3233.	        DEF_NAMEBUF;
	LD	HL,12
	ADD	HL,SP
	EX	DE,HL
	CALL	get_fattime
; 3234.	        get_fattime(&tim);
; 3235.	
; 3236.	
	LD	C,1
	PUSH	BC
	LD	HL,22
	ADD	HL,SP
	LD	C,L
	LD	B,H
	LD	HL,58
	ADD	HL,SP
	CALL	?1060
	POP	HL
	LD	(IX-52),A
; 3237.	        res = chk_mounted(&path, &dj.fs, 1);
	OR	A
	JP	NZ,?0855
?0821:
; 3238.	        if (res == FR_OK) {
	LD	HL,42
	ADD	HL,SP
	LD	(IX-14),L
	LD	(IX-13),H
; 3239.	                INIT_BUF(dj);
	LD	C,(IX+2)
	LD	B,(IX+3)
	LD	HL,20
	ADD	HL,SP
	EX	DE,HL
	CALL	follow_path
	LD	(IX-52),A
; 3240.	                res = follow_path(&dj, path);                   /* Follow the file path */
	OR	A
	JR	NZ,?0824
?0823:
	LD	(IX-52),8
?0824:
; 3241.	                if (res == FR_OK) res = FR_EXIST;               /* Any object with same name is already existing */
	LD	A,(IX-52)
	CP	4
	JR	NZ,?0826
	LD	L,(IX-14)
	LD	H,(IX-13)
	LD	BC,11
	ADD	HL,BC
	BIT	5,(HL)
	JR	Z,?0826
?0828:
?0827:
?0825:
; 3242.	                if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
	LD	(IX-52),6
?0826:
; 3243.	                        res = FR_INVALID_NAME;
	LD	A,(IX-52)
	CP	4
	JP	NZ,?0855
?0829:
; 3244.	                if (res == FR_NO_FILE) {                                /* Can create a new directory */
	LD	HL,0
	PUSH	HL
	PUSH	HL
	LD	E,(IX-34)
	LD	D,(IX-33)
	CALL	create_chain
	POP	AF
	POP	AF
	LD	(IX-50),L
	LD	(IX-49),H
	LD	(IX-48),C
	LD	(IX-47),B
; 3245.	                        dcl = create_chain(dj.fs, 0);           /* Allocate a cluster for the new directory table */
	LD	(IX-52),0
; 3246.	                        res = FR_OK;
	LD	A,L
	OR	H
	OR	C
	OR	B
	JR	NZ,?0832
?0831:
	LD	(IX-52),7
?0832:
; 3247.	                        if (dcl == 0) res = FR_DENIED;          /* No space to allocate a new cluster */
	LD	A,1
	XOR	L
	OR	H
	OR	C
	OR	B
	JR	NZ,?0834
?0833:
	LD	(IX-52),2
?0834:
; 3248.	                        if (dcl == 1) res = FR_INT_ERR;
	LD	A,L
	AND	H
	AND	C
	AND	B
	INC	A
	JR	NZ,?0836
?0835:
	LD	(IX-52),1
?0836:
; 3249.	                        if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
	XOR	A
	OR	(IX-52)
	JR	NZ,?0838
?0837:
; 3250.	                        if (res == FR_OK)                                       /* Flush FAT */
	LD	L,A
	LD	H,A
	PUSH	HL
	PUSH	HL
	LD	E,(IX-34)
	LD	D,(IX-33)
	CALL	move_window
	POP	HL
	POP	HL
	LD	(IX-52),A
?0838:
; 3251.	                                res = move_window(dj.fs, 0);
	XOR	A
	OR	(IX-52)
	JP	NZ,?0845
?0839:
; 3252.	                        if (res == FR_OK) {                                     /* Initialize the new directory table */
	PUSH	BC
	LD	L,(IX-50)
	LD	H,(IX-49)
	PUSH	HL
	LD	E,(IX-34)
	LD	D,(IX-33)
	CALL	clust2sect
	POP	AF
	POP	AF
	LD	(IX-38),L
	LD	(IX-37),H
	LD	(IX-36),C
	LD	(IX-35),B
; 3253.	                                dsc = clust2sect(dj.fs, dcl);
	LD	HL,51
	LD	C,(IX-34)
	LD	B,(IX-33)
	ADD	HL,BC
	PUSH	HL
	POP	IY
; 3254.	                                dir = dj.fs->win;
	LD	BC,512
	EX	DE,HL
	LD	L,C
	LD	H,C
	CALL	?MEMSET_L11
; 3255.	                                memset(dir, 0, SS(dj.fs));
	LD	BC,11
	LD	L,32
	CALL	?MEMSET_L11
; 3256.	                                memset(dir+DIR_Name, ' ', 8+3); /* Create "." entry */
	EX	DE,HL
	LD	(HL),46
; 3257.	                                dir[DIR_Name] = '.';
	LD	(IY+11),16
; 3258.	                                dir[DIR_Attr] = AM_DIR;
	LD	C,(IX-40)
	LD	B,(IX-39)
	LD	L,(IX-42)
	LD	(IY+22),L
	LD	H,(IX-41)
	LD	(IY+23),H
	LD	(IY+24),C
	LD	(IY+25),B
; 3259.	                                ST_DWORD(dir+DIR_WrtTime, tim);
	LD	L,(IX-50)
	LD	(IY+26),L
	LD	H,(IX-49)
	LD	(IY+27),H
	LD	L,(IX-48)
	LD	(IY+20),L
	LD	H,(IX-47)
	LD	(IY+21),H
; 3260.	                                ST_CLUST(dir, dcl);
	LD	C,E
	LD	L,C
	LD	B,D
	LD	H,B
	PUSH	IY
	POP	DE
	ADD	HL,DE
	EX	DE,HL
	PUSH	IY
	POP	HL
	LDIR
; 3261.	                                memcpy(dir+SZ_DIR, dir, SZ_DIR);        /* Create ".." entry */
	LD	(IY+33),46
	LD	HL,26
	ADD	HL,SP
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	EX	DE,HL
	LD	(IX-46),L
	LD	(IX-45),H
	LD	(IX-44),C
	LD	(IX-43),B
; 3262.	                                dir[33] = '.'; pcl = dj.sclust;
	LD	L,(IX-34)
	LD	H,(IX-33)
	LD	A,(HL)
	CP	3
	JR	NZ,?0842
	LD	HL,39
	LD	C,(IX-34)
	LD	B,(IX-33)
	ADD	HL,BC
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	L,C
	LD	H,B
	LD	C,(IX-46)
	LD	B,(IX-45)
	AND	A
	SBC	HL,BC
	JR	NZ,?0842
	EX	DE,HL
	LD	C,(IX-44)
	LD	B,(IX-43)
	SBC	HL,BC
	JR	NZ,?0842
?0844:
?0843:
?0841:
; 3263.	                                if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
	XOR	A
	LD	(IX-46),A
	LD	(IX-45),A
	LD	(IX-44),A
	LD	(IX-43),A
?0842:
; 3264.	                                        pcl = 0;
	LD	L,(IX-46)
	LD	(IY+58),L
	LD	H,(IX-45)
	LD	(IY+59),H
	LD	L,(IX-44)
	LD	(IY+52),L
	LD	H,(IX-43)
	LD	(IY+53),H
; 3265.	                                ST_CLUST(dir+SZ_DIR, pcl);
	LD	L,(IX-34)
	LD	H,(IX-33)
	INC	HL
	INC	HL
	INC	HL
	LD	B,(HL)
	LD	(IX-51),B
?0846:
	XOR	A
	OR	(IX-51)
	JR	Z,?0845
?0847:
; 3266.	                                for (n = dj.fs->csize; n; n--) {        /* Write dot entries and clear following sectors */
	LD	HL,47
	LD	C,(IX-34)
	LD	B,(IX-33)
	ADD	HL,BC
	PUSH	HL
	LD	L,(IX-38)
	LD	H,(IX-37)
	LD	C,(IX-36)
	LD	B,(IX-35)
	PUSH	BC
	PUSH	HL
	CALL	?L_INC_L03
	LD	(IX-38),L
	LD	(IX-37),H
	LD	(IX-36),C
	LD	(IX-35),B
	POP	DE
	POP	BC
	POP	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	LD	(HL),C
	INC	HL
	LD	(HL),B
; 3267.	                                        dj.fs->winsect = dsc++;
	LD	HL,5
	LD	C,(IX-34)
	LD	B,(IX-33)
	ADD	HL,BC
	LD	(HL),1
; 3268.	                                        dj.fs->wflag = 1;
	LD	HL,0
	PUSH	HL
	PUSH	HL
	LD	E,(IX-34)
	LD	D,(IX-33)
	CALL	move_window
	POP	HL
	POP	HL
	LD	(IX-52),A
; 3269.	                                        res = move_window(dj.fs, 0);
	OR	A
	JR	NZ,?0845
?0849:
?0850:
; 3270.	                                        if (res != FR_OK) break;
	LD	BC,512
	PUSH	IY
	POP	DE
	LD	L,C
	CALL	?MEMSET_L11
	DEC	(IX-51)
; 3271.	                                        memset(dir, 0, SS(dj.fs));
; 3272.	                                }
	JR	?0846
?0845:
?0840:
; 3273.	                        }
	XOR	A
	OR	(IX-52)
	JR	NZ,?0852
?0851:
	LD	HL,20
	ADD	HL,SP
	EX	DE,HL
	CALL	dir_register
	LD	(IX-52),A
?0852:
; 3274.	                        if (res == FR_OK) res = dir_register(&dj);      /* Register the object to the directoy */
	XOR	A
	OR	(IX-52)
	JR	Z,?0854
?0853:
; 3275.	                        if (res != FR_OK) {
	LD	L,(IX-48)
	LD	H,(IX-47)
	PUSH	HL
	LD	L,(IX-50)
	LD	H,(IX-49)
	PUSH	HL
	LD	E,(IX-34)
	LD	D,(IX-33)
	CALL	remove_chain
	POP	HL
	POP	HL
; 3276.	                                remove_chain(dj.fs, dcl);                       /* Could not register, remove cluster chain */
	JR	?0855
?0854:
; 3277.	                        } else {
	LD	L,(IX-16)
	LD	H,(IX-15)
	PUSH	HL
	POP	IY
; 3278.	                                dir = dj.dir;
	LD	(IY+11),16
; 3279.	                                dir[DIR_Attr] = AM_DIR;                         /* Attribute */
	LD	C,(IX-40)
	LD	B,(IX-39)
	LD	L,(IX-42)
	LD	(IY+22),L
	LD	H,(IX-41)
	LD	(IY+23),H
	LD	(IY+24),C
	LD	(IY+25),B
; 3280.	                                ST_DWORD(dir+DIR_WrtTime, tim);         /* Created time */
	LD	L,(IX-50)
	LD	(IY+26),L
	LD	H,(IX-49)
	LD	(IY+27),H
	LD	L,(IX-48)
	LD	(IY+20),L
	LD	H,(IX-47)
	LD	(IY+21),H
; 3281.	                                ST_CLUST(dir, dcl);                                     /* Table start cluster */
; 3282.	                                dj.fs->wflag = 1;
	CALL	?1066
	LD	(IX-52),A
?0855:
?0830:
?0822:
; 3283.	                                res = sync(dj.fs);
; 3284.	                        }
; 3285.	                }
; 3286.	                FREE_BUF();
; 3287.	        }
; 3288.	
	LD	A,(IX-52)
; 3289.	        LEAVE_FF(dj.fs, res);
	POP	IY
	JP	?LEAVE_DIRECT_L09
?1066:
	LD	HL,5
	LD	C,(IX-34)
	LD	B,(IX-33)
	ADD	HL,BC
	LD	(HL),1
	LD	E,(IX-34)
	LD	D,(IX-33)
	JP	sync
; 3290.	}
; 3291.	
; 3292.	
; 3293.	
; 3294.	
; 3295.	/*-----------------------------------------------------------------------*/
; 3296.	/* Change Attribute                                                      */
; 3297.	/*-----------------------------------------------------------------------*/
; 3298.	
; 3299.	FRESULT f_chmod (
; 3300.	        const TCHAR *path,      /* Pointer to the file path */
; 3301.	        BYTE value,                     /* Attribute bits */
; 3302.	        BYTE mask                       /* Attribute mask to change */
; 3303.	)
f_chmod:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	-36
	PUSH	IY
; 3304.	{
; 3305.	        FRESULT res;
; 3306.	        DIR dj;
; 3307.	        BYTE *dir;
; 3308.	        DEF_NAMEBUF;
; 3309.	
; 3310.	
	LD	E,1
	PUSH	DE
	LD	HL,6
	ADD	HL,SP
	LD	C,L
	LD	B,H
	LD	HL,42
	ADD	HL,SP
	CALL	?1060
	POP	HL
	LD	(IX-36),A
; 3311.	        res = chk_mounted(&path, &dj.fs, 1);
	OR	A
	JR	NZ,?0866
?0856:
; 3312.	        if (res == FR_OK) {
	LD	HL,26
	ADD	HL,SP
	LD	(IX-14),L
	LD	(IX-13),H
; 3313.	                INIT_BUF(dj);
	LD	C,(IX+2)
	LD	B,(IX+3)
	LD	HL,4
	ADD	HL,SP
	CALL	?1061
; 3314.	                res = follow_path(&dj, path);           /* Follow the file path */
; 3315.	                FREE_BUF();
	JR	NZ,?0859
	LD	L,(IX-14)
	LD	H,(IX-13)
	LD	BC,11
	ADD	HL,BC
	BIT	5,(HL)
	JR	Z,?0859
?0861:
?0860:
?0858:
; 3316.	                if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
	LD	(IX-36),6
?0859:
; 3317.	                        res = FR_INVALID_NAME;
	XOR	A
	OR	(IX-36)
	JR	NZ,?0866
?0862:
; 3318.	                if (res == FR_OK) {
	LD	L,(IX-16)
	LD	H,(IX-15)
	PUSH	HL
	POP	IY
; 3319.	                        dir = dj.dir;
	LD	A,IYL
	OR	IYH
	JR	NZ,?0865
?0864:
; 3320.	                        if (!dir) {                                             /* Is it a root directory? */
	LD	(IX-36),6
; 3321.	                                res = FR_INVALID_NAME;
	JR	?0866
?0865:
; 3322.	                        } else {                                                /* File or sub directory */
	LD	A,(IX+8)
	AND	39
	LD	(IX+8),A
; 3323.	                                mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;    /* Valid attribute mask */
	AND	(IX+4)
	PUSH	AF
	LD	A,(IX+8)
	CPL
	AND	(IY+11)
	LD	B,A
	POP	AF
	OR	B
	LD	(IY+11),A
; 3324.	                                dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask); /* Apply attribute change */
; 3325.	                                dj.fs->wflag = 1;
	CALL	?1066
	LD	(IX-36),A
?0866:
?0863:
?0857:
; 3326.	                                res = sync(dj.fs);
; 3327.	                        }
; 3328.	                }
; 3329.	        }
; 3330.	
	LD	A,(IX-36)
; 3331.	        LEAVE_FF(dj.fs, res);
	POP	IY
	JP	?LEAVE_DIRECT_L09
?1061:
	EX	DE,HL
	CALL	follow_path
	LD	(IX-36),A
	XOR	A
	OR	(IX-36)
	RET
; 3332.	}
; 3333.	
; 3334.	
; 3335.	
; 3336.	
; 3337.	/*-----------------------------------------------------------------------*/
; 3338.	/* Change Timestamp                                                      */
; 3339.	/*-----------------------------------------------------------------------*/
; 3340.	
; 3341.	FRESULT f_utime (
; 3342.	        const TCHAR *path,      /* Pointer to the file/directory name */
; 3343.	        const FILINFO *fno      /* Pointer to the time stamp to be set */
; 3344.	)
f_utime:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	-36
	PUSH	IY
	EXX
	PUSH	BC
	EXX
	PUSH	BC
	POP	IY
; 3345.	{
; 3346.	        FRESULT res;
; 3347.	        DIR dj;
; 3348.	        BYTE *dir;
; 3349.	        DEF_NAMEBUF;
; 3350.	
; 3351.	
	LD	C,1
	PUSH	BC
	LD	HL,8
	ADD	HL,SP
	LD	C,L
	LD	B,H
	LD	HL,44
	ADD	HL,SP
	CALL	?1060
	POP	HL
	LD	(IX-36),A
; 3352.	        res = chk_mounted(&path, &dj.fs, 1);
	OR	A
	JR	NZ,?0877
?0867:
; 3353.	        if (res == FR_OK) {
	LD	HL,28
	ADD	HL,SP
	LD	(IX-14),L
	LD	(IX-13),H
; 3354.	                INIT_BUF(dj);
	LD	C,(IX+2)
	LD	B,(IX+3)
	LD	HL,6
	ADD	HL,SP
	CALL	?1061
; 3355.	                res = follow_path(&dj, path);   /* Follow the file path */
; 3356.	                FREE_BUF();
	JR	NZ,?0870
	LD	L,(IX-14)
	LD	H,(IX-13)
	LD	BC,11
	ADD	HL,BC
	BIT	5,(HL)
	JR	Z,?0870
?0872:
?0871:
?0869:
; 3357.	                if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
	LD	(IX-36),6
?0870:
; 3358.	                        res = FR_INVALID_NAME;
	XOR	A
	OR	(IX-36)
	JR	NZ,?0877
?0873:
; 3359.	                if (res == FR_OK) {
	EXX
	LD	C,(IX-16)
	LD	A,C
	LD	B,(IX-15)
; 3360.	                        dir = dj.dir;
	OR	B
	EXX
	JR	NZ,?0876
?0875:
; 3361.	                        if (!dir) {                                     /* Root directory */
	LD	(IX-36),6
; 3362.	                                res = FR_INVALID_NAME;
	JR	?0877
?0876:
; 3363.	                        } else {                                        /* File or sub-directory */
	LD	HL,22
	EXX
	PUSH	BC
	EXX
	POP	BC
	ADD	HL,BC
	LD	E,(IY+6)
	LD	(HL),E
	LD	D,(IY+7)
	INC	HL
	LD	(HL),D
; 3364.	                                ST_WORD(dir+DIR_WrtTime, fno->ftime);
	LD	HL,24
	ADD	HL,BC
	LD	C,(IY+4)
	LD	(HL),C
	LD	B,(IY+5)
	INC	HL
	LD	(HL),B
; 3365.	                                ST_WORD(dir+DIR_WrtDate, fno->fdate);
; 3366.	                                dj.fs->wflag = 1;
	CALL	?1066
	LD	(IX-36),A
?0877:
?0874:
?0868:
; 3367.	                                res = sync(dj.fs);
; 3368.	                        }
; 3369.	                }
; 3370.	        }
; 3371.	
	LD	A,(IX-36)
; 3372.	        LEAVE_FF(dj.fs, res);
	JP	?0190
; 3373.	}
; 3374.	
; 3375.	
; 3376.	
; 3377.	
; 3378.	/*-----------------------------------------------------------------------*/
; 3379.	/* Rename File/Directory                                                 */
; 3380.	/*-----------------------------------------------------------------------*/
; 3381.	
; 3382.	FRESULT f_rename (
; 3383.	        const TCHAR *path_old,  /* Pointer to the old name */
; 3384.	        const TCHAR *path_new   /* Pointer to the new name */
; 3385.	)
f_rename:
	CALL	?ENT_AUTO_DIRECT_L09
	DEFW	65452
	PUSH	IY
; 3386.	{
; 3387.	        FRESULT res;
; 3388.	        DIR djo, djn;
; 3389.	        BYTE buf[21], *dir;
; 3390.	        DWORD dw;
; 3391.	        DEF_NAMEBUF;
; 3392.	
; 3393.	
	LD	E,1
	PUSH	DE
	LD	HL,32
	ADD	HL,SP
	LD	C,L
	LD	B,H
	LD	HL,90
	ADD	HL,SP
	CALL	?1060
	POP	HL
	LD	(IX-84),A
; 3394.	        res = chk_mounted(&path_old, &djo.fs, 1);
	OR	A
	JP	NZ,?0915
?0878:
; 3395.	        if (res == FR_OK) {
	LD	L,(IX-56)
	LD	H,(IX-55)
	LD	(IX-78),L
	LD	(IX-77),H
; 3396.	                djn.fs = djo.fs;
	LD	HL,74
	ADD	HL,SP
	LD	(IX-36),L
	LD	(IX-35),H
; 3397.	                INIT_BUF(djo);
	LD	C,(IX+2)
	LD	B,(IX+3)
	LD	HL,30
	ADD	HL,SP
	EX	DE,HL
	CALL	follow_path
	LD	(IX-84),A
; 3398.	                res = follow_path(&djo, path_old);              /* Check old object */
	XOR	A
	OR	(IX-84)
	JR	NZ,?0881
	LD	L,(IX-36)
	LD	H,(IX-35)
	LD	BC,11
	ADD	HL,BC
	BIT	5,(HL)
	JR	Z,?0881
?0883:
?0882:
?0880:
; 3399.	                if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
	LD	(IX-84),6
?0881:
; 3400.	                        res = FR_INVALID_NAME;
; 3401.	#if _FS_SHARE
; 3403.	#endif
	XOR	A
	OR	(IX-84)
	JP	NZ,?0915
?0884:
; 3404.	                if (res == FR_OK) {                                             /* Old object is found */
	LD	A,(IX-38)
	LD	H,(IX-37)
	OR	H
	JR	NZ,?0887
?0886:
; 3405.	                        if (!djo.dir) {                                         /* Is root dir? */
	LD	(IX-84),4
; 3406.	                                res = FR_NO_FILE;
	JP	?0915
?0887:
; 3407.	                        } else {
	LD	BC,21
	LD	HL,52
	ADD	HL,SP
	EX	DE,HL
	LD	L,(IX-38)
	LD	H,(IX-37)
	LD	C,11
	ADD	HL,BC
	LD	C,21
	LDIR
; 3408.	                                memcpy(buf, djo.dir+DIR_Attr, 21);              /* Save the object information except for name */
	LD	C,22
	LD	HL,8
	ADD	HL,SP
	EX	DE,HL
	LD	HL,30
	ADD	HL,SP
	LDIR
; 3409.	                                memcpy(&djn, &djo, sizeof(DIR));                /* Check new object */
	LD	C,(IX+4)
	LD	B,(IX+5)
	LD	HL,8
	ADD	HL,SP
	EX	DE,HL
	CALL	follow_path
	LD	(IX-84),A
; 3410.	                                res = follow_path(&djn, path_new);
	OR	A
	JR	NZ,?0890
?0889:
	LD	(IX-84),8
?0890:
; 3411.	                                if (res == FR_OK) res = FR_EXIST;               /* The new object name is already existing */
	LD	A,(IX-84)
	CP	4
	JP	NZ,?0915
?0891:
; 3412.	                                if (res == FR_NO_FILE) {                                /* Is it a valid path and no name collision? */
; 3413.	/* Start critical section that any interruption or error can cause cross-link */
	LD	HL,8
	ADD	HL,SP
	EX	DE,HL
	CALL	dir_register
	LD	(IX-84),A
; 3414.	                                        res = dir_register(&djn);                       /* Register the new entry */
	OR	A
	JP	NZ,?0915
?0893:
; 3415.	                                        if (res == FR_OK) {
	LD	L,(IX-60)
	LD	H,(IX-59)
	PUSH	HL
	POP	IY
; 3416.	                                                dir = djn.dir;                                  /* Copy object information except for name */
	LD	BC,19
	LD	HL,13
	PUSH	IY
	POP	DE
	ADD	HL,DE
	EX	DE,HL
	LD	HL,52
	ADD	HL,SP
	LD	C,2
	ADD	HL,BC
	LD	C,19
	LDIR
; 3417.	                                                memcpy(dir+13, buf+2, 19);
	LD	B,(IX-34)
	SET	5,B
	LD	(IY+11),B
; 3418.	                                                dir[DIR_Attr] = buf[0] | AM_ARC;
	LD	HL,5
	LD	C,(IX-56)
	LD	B,(IX-55)
	ADD	HL,BC
	LD	(HL),1
; 3419.	                                                djo.fs->wflag = 1;
	LD	L,(IX-50)
	LD	H,(IX-49)
	LD	C,(IX-72)
	LD	B,(IX-71)
	AND	A
	SBC	HL,BC
	JR	NZ,?1023
	LD	L,(IX-48)
	LD	H,(IX-47)
	LD	C,(IX-70)
	LD	B,(IX-69)
	SBC	HL,BC
	JP	Z,?0903
?1023:
	BIT	4,(IY+11)
	JP	Z,?0903
?0898:
?0897:
?0895:
; 3420.	                                                if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {             /* Update .. entry in the directory if needed */
	PUSH	IY
	POP	DE
	CALL	LD_CLUST
	PUSH	BC
	PUSH	HL
	LD	E,(IX-78)
	LD	D,(IX-77)
	CALL	clust2sect
	POP	AF
	POP	AF
; 3421.	                                                        dw = clust2sect(djn.fs, LD_CLUST(dir));
	LD	A,L
	OR	H
	OR	C
	OR	B
	JR	NZ,?0900
?0899:
; 3422.	                                                        if (!dw) {
	LD	(IX-84),2
; 3423.	                                                                res = FR_INT_ERR;
	JP	?0903
?0900:
; 3424.	                                                        } else {
	PUSH	BC
	PUSH	HL
	LD	E,(IX-78)
	LD	D,(IX-77)
	CALL	move_window
	POP	HL
	POP	HL
	LD	(IX-84),A
; 3425.	                                                                res = move_window(djn.fs, dw);
	LD	HL,51
	LD	C,(IX-78)
	LD	B,(IX-77)
	ADD	HL,BC
	LD	BC,32
	ADD	HL,BC
	PUSH	HL
	POP	IY
; 3426.	                                                                dir = djn.fs->win+SZ_DIR;       /* .. entry */
	OR	A
	JR	NZ,?0903
	LD	A,(IY+1)
	CP	46
	JR	NZ,?0903
?0905:
?0904:
?0902:
; 3427.	                                                                if (res == FR_OK && dir[1] == '.') {
	LD	L,(IX-78)
	LD	H,(IX-77)
	LD	A,(HL)
	CP	3
	JR	NZ,?0909
	LD	HL,39
	LD	C,(IX-78)
	LD	B,(IX-77)
	ADD	HL,BC
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	L,C
	LD	H,B
	LD	C,(IX-72)
	LD	B,(IX-71)
	AND	A
	SBC	HL,BC
	JR	NZ,?0909
	EX	DE,HL
	LD	C,(IX-70)
	LD	B,(IX-69)
	SBC	HL,BC
	JR	NZ,?0909
	LD	C,L
	LD	B,H
	JR	?0910
?0909:
	LD	HL,14
	ADD	HL,SP
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	EX	DE,HL
?0910:
; 3428.	                                                                        dw = (djn.fs->fs_type == FS_FAT32 && djn.sclust == djn.fs->dirbase) ? 0 : djn.sclust;
	LD	(IY+26),L
	LD	(IY+27),H
	LD	(IY+20),C
	LD	(IY+21),B
; 3429.	                                                                        ST_CLUST(dir, dw);
	LD	HL,5
	LD	C,(IX-78)
	LD	B,(IX-77)
	ADD	HL,BC
	LD	(HL),1
?0903:
?0901:
?0896:
; 3430.	                                                                        djn.fs->wflag = 1;
; 3431.	                                                                }
; 3432.	                                                        }
; 3433.	                                                }
	XOR	A
	OR	(IX-84)
	JR	NZ,?0915
?0912:
; 3434.	                                                if (res == FR_OK) {
	LD	HL,30
	ADD	HL,SP
	EX	DE,HL
	CALL	dir_remove
	LD	(IX-84),A
; 3435.	                                                        res = dir_remove(&djo);         /* Remove old entry */
	OR	A
	JR	NZ,?0915
?0914:
; 3436.	                                                        if (res == FR_OK)
	LD	E,(IX-56)
	LD	D,(IX-55)
	CALL	sync
	LD	(IX-84),A
?0915:
?0913:
?0894:
?0892:
?0888:
?0885:
?0879:
; 3437.	                                                                res = sync(djo.fs);
; 3438.	                                                }
; 3439.	                                        }
; 3440.	/* End critical section */
; 3441.	                                }
; 3442.	                        }
; 3443.	                }
; 3444.	                FREE_BUF();
; 3445.	        }
	LD	A,(IX-84)
; 3446.	        LEAVE_FF(djo.fs, res);
	POP	IY
	JP	?LEAVE_DIRECT_L09
; 3447.	}
; 3448.	
; 3449.	#endif /* !_FS_READONLY */
; 3450.	#endif /* _FS_MINIMIZE == 0 */
; 3451.	#endif /* _FS_MINIMIZE <= 1 */
; 3452.	#endif /* _FS_MINIMIZE <= 2 */
; 3453.	
; 3454.	
; 3455.	
; 3456.	/*-----------------------------------------------------------------------*/
; 3457.	/* Forward data to the stream directly (available on only tiny cfg)      */
; 3458.	/*-----------------------------------------------------------------------*/
; 3459.	#if _USE_FORWARD && _FS_TINY
; 3512.	#endif /* _USE_FORWARD */
; 3513.	
; 3514.	
; 3515.	
; 3516.	#if _USE_MKFS && !_FS_READONLY
; 3552.	#if _MAX_SS != 512                                      /* Get disk sector size */
; 3555.	#endif
; 3711.	#if _USE_ERASE  /* Erase data area if needed */
; 3718.	#endif
; 3734.	#endif /* _USE_MKFS && !_FS_READONLY */
; 3735.	
; 3736.	
; 3737.	
; 3738.	
; 3739.	#if _USE_STRFUNC
; 3759.	#if _LFN_UNICODE                                        /* Read a character in UTF-8 encoding */
; 3778.	#endif
; 3779.	#if _USE_STRFUNC >= 2
; 3781.	#endif
; 3792.	#if !_FS_READONLY
; 3806.	#if _USE_STRFUNC >= 2
; 3808.	#endif
; 3810.	#if _LFN_UNICODE        /* Write the character in UTF-8 encoding */
; 3826.	#else                           /* Write the character without conversion */
; 3829.	#endif
; 3953.	#endif /* !_FS_READONLY */
; 3954.	#endif /* _USE_STRFUNC */
	RSEG	CSTR
?0289:
	DEFB	'"*+,:;<=>?[]|'
	DEFB	127,0
	END
